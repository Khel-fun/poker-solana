use crate::error::PokerError;
use crate::state::random_state::RandomState;
use crate::state::PokerTable;
use anchor_lang::prelude::*;
use inco_lightning::cpi::accounts::{Allow, Operation};
use inco_lightning::cpi::{allow, e_rand};
use inco_lightning::program::IncoLightning;
use inco_lightning::types::Euint128;

/// Generate an encrypted random number using Inco's e_rand
///
/// This instruction:
/// 1. Calls Inco's e_rand to generate a truly random encrypted value
/// 2. Stores the handle in a RandomState PDA
/// 3. Grants the backend permission to decrypt
///
/// Backend can then call the Inco SDK to decrypt and use the value off-chain.
/// This is a VRF alternative - random values are generated by Inco's TEE network.
pub fn handler<'info>(
    ctx: Context<'_, '_, '_, 'info, GenerateRandom<'info>>,
    nonce: u64,
) -> Result<()> {
    let random_state = &mut ctx.accounts.random_state;
    let cpi_program = ctx.accounts.inco_lightning_program.to_account_info();
    let backend = ctx.accounts.backend.to_account_info();

    // Generate encrypted random value using Inco's e_rand
    // Second parameter 0 = working with encrypted handles
    let random_handle: Euint128 = e_rand(
        CpiContext::new(
            cpi_program.clone(),
            Operation {
                signer: backend.clone(),
            },
        ),
        0, // ciphertext mode
    )?;

    // Store the handle and metadata
    random_state.random_handle = random_handle;
    random_state.requester = ctx.accounts.backend.key();
    random_state.nonce = nonce;
    random_state.bump = ctx.bumps.random_state;

    msg!(
        "Random generated via e_rand: nonce={}, requester={}",
        nonce,
        random_state.requester
    );

    // Grant backend permission to decrypt via remaining_accounts
    // remaining_accounts[0] = allowance PDA (writable)
    if ctx.remaining_accounts.len() >= 1 {
        let allowance_account = &ctx.remaining_accounts[0];

        allow(
            CpiContext::new(
                cpi_program,
                Allow {
                    allowance_account: allowance_account.clone(),
                    signer: backend.clone(),
                    allowed_address: ctx.accounts.backend.to_account_info(),
                    system_program: ctx.accounts.system_program.to_account_info(),
                },
            ),
            random_handle.0, // Extract the u128 handle value
            true,            // Grant access
            ctx.accounts.backend.key(),
        )?;

        msg!("Decrypt permission granted to backend");
    }

    Ok(())
}

#[derive(Accounts)]
#[instruction(nonce: u64)]
pub struct GenerateRandom<'info> {
    /// The table (to verify backend authority)
    #[account(
        constraint = table.backend == backend.key() @ PokerError::NotBackend
    )]
    pub table: Account<'info, PokerTable>,

    /// RandomState PDA - created for each unique nonce
    #[account(
        init,
        payer = backend,
        space = RandomState::LEN,
        seeds = [b"random", table.key().as_ref(), &nonce.to_le_bytes()],
        bump
    )]
    pub random_state: Account<'info, RandomState>,

    /// Backend authority (must be table's backend)
    #[account(mut)]
    pub backend: Signer<'info>,

    /// Inco Lightning program for encrypted operations
    pub inco_lightning_program: Program<'info, IncoLightning>,

    pub system_program: Program<'info, System>,
}
