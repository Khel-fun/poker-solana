
/* Autogenerated file, do not edit! */

/* eslint-disable */

import { Noir, InputMap, type CompiledCircuit, type ForeignCallHandler } from "@noir-lang/noir_js"

export { type ForeignCallHandler } from "@noir-lang/noir_js"

export type Field = string;


export type calculate_commitmentInputType = {
  cards: Field[];
  players: Field[];
  player_status: boolean[];
}

export type calculate_commitmentReturnType = Field[];
export const calculate_commitment_circuit: CompiledCircuit = {"abi":{"parameters":[{"name":"cards","type":{"kind":"array","length":10,"type":{"kind":"field"}},"visibility":"private"},{"name":"players","type":{"kind":"array","length":5,"type":{"kind":"field"}},"visibility":"private"},{"name":"player_status","type":{"kind":"array","length":5,"type":{"kind":"boolean"}},"visibility":"private"}],"return_type":{"abi_type":{"kind":"array","length":10,"type":{"kind":"field"}},"visibility":"private"},"error_types":{}},"bytecode":"H4sIAAAAAAAA/7WWu04CQRSGzwLe8IIiXpGLigqKCoKKiooCYmUsbYwhSGECagwWljyC8QV8CqOPQ2dpY+9/4mBWswM7JjvJlxNmZ//5A8z5R6Pv4RG1VKyU7ivFWvmidFOtXtWq5etaAfNe8VwDdlFdournBg3mhgzm3AZzw6LqR/NzUNTY5cldI/4ceT3Nv9TrZ+fhxPvxw9vtY7bx+fSB537dWpWhuk+A2u5j02v3AQf93ourU1S/qAHduiCYBjNgVqKjmdAJgTkwDxYkOjZRe1vohEEELIIliY7dhE4ULIMVsCrRcejmZToxEAdrICHR6TChkwTrYANsSnQ6Re1voZMCW2Ab7Eh0ukzopMEu2AP7Ep1uUQda6GTAATgEWYlOjwmdHMiDI1DQvcsjKGq78+ISa/++12ZoHvNr/+0rROq+RshaX9xHw6Tua5Ss9xUldV9jZK0vzpgYqfsaJ+t9JUnd1wRZ64vzN0XqvibJel9pUvflJWt98d0kQ+q+psh6XzlS9+Uzv/bnbtj0x3cFznnOB85XzkbONc4kzhO+i3D+c9ZwznG2cJ/l3sHnwS18N4dTtw/3Ve5h3C/4bPI54P8c/778XfoM/H0BOTPhtcQKAAA=","debug_symbols":"nZPdqoQgFIXfxesuMn/SXuVwCCsbBLFw6sAhevcxzZouHIZu9kp362OZ7QV0spkftTL98ATVzwIaq7RWj1oPrZjUYNzusmYgLuvJSum2wFvfuUZhpZlAZWatM/An9Oxfeo7CeJ2Edd08A9J0Th2wV1puT2t2uvO0leKC7G6KETkABH5PoPQgsOIOgUAcCaS4RcC8PAjpU+A0AZFiByBenn5+8ZMPfsx5BJD8FqGk8QyI5SRFKNMEzGC8S8zI+R3h9xlYQY8MCKcyfLwJfP4NNL/cxK9biVbZywwAAiqWAepr6SvzlfsK8yAwSBEEBcFBAgFuiHVLZpVotNwHrJ9N+zZv0/8YO3EiRzu0sput3HL5nkv6Ag==","file_map":{"19":{"source":"// Exposed only for usage in `std::meta`\npub(crate) mod poseidon2;\n\nuse crate::default::Default;\nuse crate::embedded_curve_ops::{\n    EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_array_return,\n};\nuse crate::meta::derive_via;\n\n#[foreign(sha256_compression)]\n// docs:start:sha256_compression\npub fn sha256_compression(input: [u32; 16], state: [u32; 8]) -> [u32; 8] {}\n// docs:end:sha256_compression\n\n#[foreign(keccakf1600)]\n// docs:start:keccakf1600\npub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {}\n// docs:end:keccakf1600\n\npub mod keccak {\n    #[deprecated(\"This function has been moved to std::hash::keccakf1600\")]\n    pub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {\n        super::keccakf1600(input)\n    }\n}\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{\n    if crate::runtime::is_unconstrained() {\n        // Temporary measure while Barretenberg is main proving system.\n        // Please open an issue if you're working on another proving system and running into problems due to this.\n        crate::static_assert(\n            N <= 1024,\n            \"Barretenberg cannot prove blake3 hashes with inputs larger than 1024 bytes\",\n        );\n    }\n    __blake3(input)\n}\n\n#[foreign(blake3)]\nfn __blake3<let N: u32>(input: [u8; N]) -> [u8; 32] {}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\n#[inline_always]\npub fn pedersen_commitment_with_separator<let N: u32>(\n    input: [Field; N],\n    separator: u32,\n) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        // we use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        points[i] = from_field_unsafe(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    multi_scalar_mul(generators, points)\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[no_predicates]\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let mut scalars: [EmbeddedCurveScalar; N + 1] = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N + 1];\n    let mut generators: [EmbeddedCurvePoint; N + 1] =\n        [EmbeddedCurvePoint::point_at_infinity(); N + 1];\n    let domain_generators: [EmbeddedCurvePoint; N] =\n        derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n\n    for i in 0..N {\n        scalars[i] = from_field_unsafe(input[i]);\n        generators[i] = domain_generators[i];\n    }\n    scalars[N] = EmbeddedCurveScalar { lo: N as Field, hi: 0 as Field };\n\n    let length_generator: [EmbeddedCurvePoint; 1] =\n        derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    generators[N] = length_generator[0];\n    multi_scalar_mul_array_return(generators, scalars, true)[0].x\n}\n\n#[field(bn254)]\n#[inline_always]\npub fn derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    // TODO(https://github.com/noir-lang/noir/issues/5672): Add back assert_constant on starting_index\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {}\n\n#[field(bn254)]\n// Decompose the input 'bn254 scalar' into two 128 bits limbs.\n// It is called 'unsafe' because it does not assert the limbs are 128 bits\n// Assuming the limbs are 128 bits:\n// Assert the decomposition does not overflow the field size.\nfn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {\n    // Safety: xlo and xhi decomposition is checked below\n    let (xlo, xhi) = unsafe { crate::field::bn254::decompose_hint(scalar) };\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);\n    // Check that the decomposition does not overflow the field size\n    let (a, b) = if xhi == crate::field::bn254::PHI {\n        (xlo, crate::field::bn254::PLO)\n    } else {\n        (xhi, crate::field::bn254::PHI)\n    };\n    crate::field::bn254::assert_lt(a, b);\n\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n\npub fn poseidon2_permutation<let N: u32>(input: [Field; N], state_len: u32) -> [Field; N] {\n    assert_eq(input.len(), state_len);\n    poseidon2_permutation_internal(input)\n}\n\n#[foreign(poseidon2_permutation)]\nfn poseidon2_permutation_internal<let N: u32>(input: [Field; N]) -> [Field; N] {}\n\n// Generic hashing support.\n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\n#[derive_via(derive_hash)]\npub trait Hash {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher;\n}\n\n// docs:start:derive_hash\ncomptime fn derive_hash(s: TypeDefinition) -> Quoted {\n    let name = quote { $crate::hash::Hash };\n    let signature = quote { fn hash<H>(_self: Self, _state: &mut H) where H: $crate::hash::Hasher };\n    let for_each_field = |name| quote { _self.$name.hash(_state); };\n    crate::meta::make_trait_impl(\n        s,\n        name,\n        signature,\n        for_each_field,\n        quote {},\n        |fields| fields,\n    )\n}\n// docs:end:derive_hash\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\npub trait Hasher {\n    fn finish(self) -> Field;\n\n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\npub trait BuildHasher {\n    type H: Hasher;\n\n    fn build_hasher(self) -> H;\n}\n\npub struct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    type H = H;\n\n    fn build_hasher(_self: Self) -> H {\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn default() -> Self {\n        BuildHasherDefault {}\n    }\n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u1 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u128 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u8 as Field);\n    }\n}\n\nimpl Hash for i16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u16 as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u32 as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u64 as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H)\n    where\n        H: Hasher,\n    {}\n}\n\nimpl<T, let N: u32> Hash for [T; N]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B)\nwhere\n    A: Hash,\n    B: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n    E: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n// Some test vectors for Pedersen hash and Pedersen Commitment.\n// They have been generated using the same functions so the tests are for now useless\n// but they will be useful when we switch to Noir implementation.\n#[test]\nfn assert_pedersen() {\n    assert_eq(\n        pedersen_hash_with_separator([1], 1),\n        0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1], 1),\n        EmbeddedCurvePoint {\n            x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,\n            y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,\n            is_infinite: false,\n        },\n    );\n\n    assert_eq(\n        pedersen_hash_with_separator([1, 2], 2),\n        0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2], 2),\n        EmbeddedCurvePoint {\n            x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,\n            y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3], 3),\n        0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3], 3),\n        EmbeddedCurvePoint {\n            x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,\n            y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4], 4),\n        0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4], 4),\n        EmbeddedCurvePoint {\n            x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,\n            y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5),\n        0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5),\n        EmbeddedCurvePoint {\n            x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,\n            y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6),\n        0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6),\n        EmbeddedCurvePoint {\n            x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,\n            y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        EmbeddedCurvePoint {\n            x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,\n            y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        EmbeddedCurvePoint {\n            x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,\n            y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        EmbeddedCurvePoint {\n            x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,\n            y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        EmbeddedCurvePoint {\n            x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,\n            y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,\n            is_infinite: false,\n        },\n    );\n}\n","path":"std/hash/mod.nr"},"51":{"source":"use poseidon::poseidon2::Poseidon2;\nuse std::field::bn254::assert_lt;\n\n/// Number of cards in a standard deck.\npub global DECK_SIZE: u32 = 52;\n\n/// Number of cards to deal for gameplay (5 players * 2 cards + 5 community cards = 15).\npub global CARDS_TO_DEAL: u32 = 15;\n\n// Domain separators prevent cross-protocol hash collisions.\npub global HASH_DOMAIN_SEPARATOR_SEED: Field = 1;\npub global HASH_DOMAIN_SEPARATOR_DECK: Field = 2;\npub global HASH_DOMAIN_SEPARATOR_CARD: Field = 3;\n\n/// Domain separator for Fisher-Yates RNG state transitions.\npub global HASH_DOMAIN_SEPARATOR_RNG: Field = 4;\npub global PADDING_NONCE: Field = 5;\n\n/// Performs a deterministic Fisher-Yates shuffle on a 52-card deck.\n///\n/// # Arguments\n/// * `seed` - Random seed from on-chain randomness source.\n///\n/// # Returns\n/// A shuffled deck represented as an array of Field elements (0-51).\n///\n/// # Security Properties\n/// - Deterministic: Same seed always produces the same shuffle.\n/// - Uniform: Each permutation is equally likely given a uniformly random seed.\n/// - Verifiable: The shuffle can be independently verified with the seed.\n#[export]\npub fn fisher_yates_shuffle(seed: Field) -> [Field; DECK_SIZE] {\n    // Initialize the deck as 0-51 indices\n    let mut deck = [0; DECK_SIZE];\n    for i in 0..DECK_SIZE {\n        deck[i] = i as Field;\n    }\n\n    // Initialize the RNG state with the random seed using domain separator\n    let mut rng_state = Poseidon2::hash([HASH_DOMAIN_SEPARATOR_RNG, seed], 2);\n\n    // Perform the Fisher-Yates shuffle\n    // Iterate from the last element down to the second element\n    for i in 0..(DECK_SIZE - 1) {\n        let idx = (DECK_SIZE - 1) - i;\n\n        // Generate random hash with domain-separated RNG state update\n        rng_state = Poseidon2::hash([HASH_DOMAIN_SEPARATOR_RNG, rng_state, idx as Field], 3);\n\n        // Calculate the swap index unconstrained\n        let range = (idx + 1) as Field;\n        // Safety: constraints enabled by proceeding assertions\n        let (quotient, remainder) = unsafe { divide_hint(rng_state, range) };\n\n        // Constrain the division result: rng_state = quotient * range + remainder\n        assert(rng_state == quotient * range + remainder);\n        // Ensure remainder is in valid range [0, range)\n        assert_lt(remainder, range);\n\n        let swap_idx = remainder as u32;\n\n        // Perform the swap\n        if swap_idx != idx {\n            let temp = deck[idx];\n            deck[idx] = deck[swap_idx];\n            deck[swap_idx] = temp;\n        }\n    }\n\n    deck\n}\n\n/// Unconstrained hint for field division.\n/// Computes (quotient, remainder) such that numerator = quotient * denominator + remainder.\nunconstrained fn divide_hint(numerator: Field, denominator: Field) -> (Field, Field) {\n    // NOTE: assuming denominator is small enough to fit in u32 (as is the case for a DECK_SIZE of 52)\n    let den_u64 = denominator as u64;\n    // Minimal check to avoid division by zero\n    assert(den_u64 != 0);\n    // Ensure denominator fits in u32 to guarantee 'remainder * 256' fits in u64\n    assert(den_u64 <= 4294967295);\n\n    let bytes: [u8; 32] = numerator.to_be_bytes();\n    let mut remainder: u64 = 0;\n    let mut quotient: Field = 0;\n\n    for i in 0..32 {\n        let b = bytes[i] as u64;\n        let val = remainder * 256 + b;\n        let q_digit = val / den_u64;\n        let r_digit = val % den_u64;\n\n        quotient = quotient * 256 + (q_digit as Field);\n        remainder = r_digit;\n    }\n    (quotient, remainder as Field)\n}\n\n/// Computes the Merkle root of a shuffled deck.\n///\n/// # Arguments\n/// * `deck` - The shuffled deck array.\n/// * `seed` - The shuffle seed (used to derive salt for binding).\n///\n/// # Returns\n/// The Merkle root hash of the deck.\n///\n/// # Implementation Notes\n/// - Uses a 64-leaf tree (52 cards + 12 padding leaves).\n/// - Each card is hashed with its position and a seed-derived salt.\n#[export]\npub fn merkle_root(deck: [Field; DECK_SIZE], seed: Field) -> Field {\n    // Generate salt for binding cards to this specific shuffle\n    let salt = derive_salt(seed);\n\n    // Hash all cards directly into buffer\n    let mut buffer: [Field; 64] = [0; 64];\n\n    for i in 0..DECK_SIZE {\n        buffer[i] = hash_card_in_deck(deck[i], i as Field, salt);\n    }\n\n    // Pad buffer with a fixed value to reach power of 2 tree size\n    let padding = Poseidon2::hash([HASH_DOMAIN_SEPARATOR_DECK, PADDING_NONCE], 2);\n    for i in DECK_SIZE..64 {\n        buffer[i] = padding;\n    }\n\n    // Build tree bottom-up, reusing buffer space\n    // After each level, results are stored in the first half of the buffer\n    let mut size = 64;\n    for _ in 0..6 {\n        let next_size = size / 2;\n        for i in 0..next_size {\n            buffer[i] = merkle_a_pair(buffer[i * 2], buffer[i * 2 + 1]);\n        }\n        size = next_size;\n    }\n\n    buffer[0]\n}\n\n/// Derives a salt from the shuffle seed for card hashing.\npub fn derive_salt(seed: Field) -> Field {\n    Poseidon2::hash([seed, HASH_DOMAIN_SEPARATOR_CARD], 2)\n}\n\n/// Hashes a card at a specific position with salt.\n/// The position ensures uniqueness even for duplicate card values.\npub fn hash_card_in_deck(card: Field, position: Field, salt: Field) -> Field {\n    Poseidon2::hash([HASH_DOMAIN_SEPARATOR_CARD, card, position, salt], 4)\n}\n\n/// Hashes two child nodes to produce a parent node in the Merkle tree.\npub fn merkle_a_pair(left: Field, right: Field) -> Field {\n    Poseidon2::hash([left, right], 2)\n}\n\n/// Extracts the first CARDS_TO_DEAL cards from the shuffled deck.\n///\n/// # Arguments\n/// * `deck` - The shuffled deck array.\n///\n/// # Returns\n/// An array of the first 15 cards for gameplay.\n#[export]\npub fn get_cards(deck: [Field; DECK_SIZE]) -> [Field; CARDS_TO_DEAL] {\n    let mut cards = [0; CARDS_TO_DEAL];\n    for i in 0..CARDS_TO_DEAL {\n        cards[i] = deck[i];\n    }\n    cards\n}\n\n/// Commitments of card allocations to respective players\n///\n/// # Arguments\n/// * `cards` - The cards array.\n/// * `players` - The players array.\n/// * `player_status` - The player status array - if player is not in the game, commitment is 0\n///\n/// # Returns\n/// An array of commitments for the cards.\n#[export]\npub fn calculate_commitment(\n    cards: [Field; 10],\n    players: [Field; 5],\n    player_status: [bool; 5],\n) -> [Field; 10] {\n    let mut commitments: [Field; 10] = [0; 10];\n    let mut k = 0;\n\n    for i in 0..cards.len() {\n        let player: Field = players[k];\n\n        commitments[i] = if player_status[k] {\n            Poseidon2::hash([cards[i], player], 2)\n        } else {\n            0\n        };\n\n        if (i % 2 != 0) {\n            k += 1;\n        }\n    }\n\n    commitments\n}\n\n/// Commitment of community cards\n///\n/// # Arguments\n/// * `cards` - The cards array.\n///\n/// # Returns\n/// The commitment for the community cards.\n#[export]\npub fn calculate_community_commitment(cards: [Field; 5]) -> Field {\n    Poseidon2::hash([cards[0], cards[1], cards[2], cards[3], cards[4]], 5)\n}\n\n// =============================================================================\n// Test Module\n// =============================================================================\n\nmod tests {\n    use super::{\n        calculate_commitment, calculate_community_commitment, CARDS_TO_DEAL, DECK_SIZE, derive_salt,\n        fisher_yates_shuffle, get_cards, hash_card_in_deck, merkle_a_pair, merkle_root,\n    };\n    use poseidon::poseidon2::Poseidon2;\n\n    // -------------------------------------------------------------------------\n    // Fisher-Yates Shuffle Tests\n    // -------------------------------------------------------------------------\n\n    #[test]\n    fn test_shuffle_produces_valid_permutation() {\n        // A valid permutation contains each card exactly once\n        let seed: Field = 12345;\n        let deck = fisher_yates_shuffle(seed);\n\n        // Check that all cards 0-51 appear exactly once\n        let mut card_count: [u32; DECK_SIZE] = [0; DECK_SIZE];\n        for i in 0..DECK_SIZE {\n            let card_idx = deck[i] as u32;\n            assert(card_idx < DECK_SIZE, \"Card index out of bounds\");\n            card_count[card_idx] += 1;\n        }\n\n        for i in 0..DECK_SIZE {\n            assert(card_count[i] == 1, \"Each card must appear exactly once\");\n        }\n    }\n\n    #[test]\n    fn test_shuffle_is_deterministic() {\n        // Same seed must produce the same shuffle\n        let seed: Field = 0xabcdef123456;\n        let deck1 = fisher_yates_shuffle(seed);\n        let deck2 = fisher_yates_shuffle(seed);\n\n        for i in 0..DECK_SIZE {\n            assert(deck1[i] == deck2[i], \"Shuffle must be deterministic\");\n        }\n    }\n\n    #[test]\n    fn test_shuffle_different_seeds_produce_different_decks() {\n        let deck1 = fisher_yates_shuffle(1);\n        let deck2 = fisher_yates_shuffle(2);\n\n        // At least one card should be in a different position\n        let mut has_difference = false;\n        for i in 0..DECK_SIZE {\n            if deck1[i] != deck2[i] {\n                has_difference = true;\n            }\n        }\n        assert(has_difference, \"Different seeds should produce different shuffles\");\n    }\n\n    #[test]\n    fn test_shuffle_with_zero_seed() {\n        // Zero seed should still produce a valid permutation\n        let deck = fisher_yates_shuffle(0);\n\n        let mut card_count: [u32; DECK_SIZE] = [0; DECK_SIZE];\n        for i in 0..DECK_SIZE {\n            let card_idx = deck[i] as u32;\n            card_count[card_idx] += 1;\n        }\n\n        for i in 0..DECK_SIZE {\n            assert(card_count[i] == 1, \"Each card must appear exactly once\");\n        }\n    }\n\n    // -------------------------------------------------------------------------\n    // Merkle Root Tests\n    // -------------------------------------------------------------------------\n\n    #[test]\n    fn test_merkle_root_is_deterministic() {\n        let seed: Field = 42;\n        let deck = fisher_yates_shuffle(seed);\n\n        let root1 = merkle_root(deck, seed);\n        let root2 = merkle_root(deck, seed);\n\n        assert(root1 == root2, \"Merkle root must be deterministic\");\n    }\n\n    #[test]\n    fn test_merkle_root_different_decks_produce_different_roots() {\n        let deck1 = fisher_yates_shuffle(100);\n        let deck2 = fisher_yates_shuffle(200);\n\n        let root1 = merkle_root(deck1, 100);\n        let root2 = merkle_root(deck2, 200);\n\n        assert(root1 != root2, \"Different decks should produce different roots\");\n    }\n\n    #[test]\n    fn test_merkle_root_same_deck_different_seed_produces_different_root() {\n        // The seed affects the salt, so same deck with different seeds = different roots\n        let deck = fisher_yates_shuffle(123);\n\n        let root1 = merkle_root(deck, 123);\n        let root2 = merkle_root(deck, 456);\n\n        assert(root1 != root2, \"Same deck with different seeds should produce different roots\");\n    }\n\n    // -------------------------------------------------------------------------\n    // Helper Function Tests\n    // -------------------------------------------------------------------------\n\n    #[test]\n    fn test_derive_salt_is_deterministic() {\n        let seed: Field = 999;\n        let salt1 = derive_salt(seed);\n        let salt2 = derive_salt(seed);\n\n        assert(salt1 == salt2, \"derive_salt must be deterministic\");\n    }\n\n    #[test]\n    fn test_derive_salt_different_seeds_produce_different_salts() {\n        let salt1 = derive_salt(1);\n        let salt2 = derive_salt(2);\n\n        assert(salt1 != salt2, \"Different seeds should produce different salts\");\n    }\n\n    #[test]\n    fn test_hash_card_is_deterministic() {\n        let card: Field = 10;\n        let position: Field = 5;\n        let salt: Field = 12345;\n\n        let hash1 = hash_card_in_deck(card, position, salt);\n        let hash2 = hash_card_in_deck(card, position, salt);\n\n        assert(hash1 == hash2, \"hash_card_in_deck must be deterministic\");\n    }\n\n    #[test]\n    fn test_hash_card_position_affects_hash() {\n        let card: Field = 10;\n        let salt: Field = 12345;\n\n        let hash1 = hash_card_in_deck(card, 0, salt);\n        let hash2 = hash_card_in_deck(card, 1, salt);\n\n        assert(hash1 != hash2, \"Different positions should produce different hashes\");\n    }\n\n    #[test]\n    fn test_merkle_pair_is_deterministic() {\n        let left: Field = 111;\n        let right: Field = 222;\n\n        let hash1 = merkle_a_pair(left, right);\n        let hash2 = merkle_a_pair(left, right);\n\n        assert(hash1 == hash2, \"merkle_a_pair must be deterministic\");\n    }\n\n    #[test]\n    fn test_merkle_pair_order_matters() {\n        let a: Field = 111;\n        let b: Field = 222;\n\n        let hash1 = merkle_a_pair(a, b);\n        let hash2 = merkle_a_pair(b, a);\n\n        assert(hash1 != hash2, \"merkle_a_pair should be order-sensitive\");\n    }\n\n    // -------------------------------------------------------------------------\n    // Card Selection Tests\n    // -------------------------------------------------------------------------\n\n    #[test]\n    fn test_get_cards_extracts_first_fifteen() {\n        let deck = fisher_yates_shuffle(777);\n        let cards = get_cards(deck);\n\n        for i in 0..CARDS_TO_DEAL {\n            assert(cards[i] == deck[i], \"get_cards should extract cards in order\");\n        }\n    }\n\n    #[test]\n    fn test_get_cards_returns_correct_count() {\n        let deck = fisher_yates_shuffle(888);\n        let cards = get_cards(deck);\n\n        // Verify we get exactly CARDS_TO_DEAL cards\n        assert(cards.len() == CARDS_TO_DEAL, \"Should return CARDS_TO_DEAL cards\");\n    }\n\n    // -------------------------------------------------------------------------\n    // Integration Tests\n    // -------------------------------------------------------------------------\n\n    #[test]\n    fn test_full_shuffle_and_verify_workflow() {\n        // Simulate the full workflow: shuffle, compute root, extract cards\n        let seed: Field = 0xdeadbeef;\n\n        // Step 1: Shuffle\n        let deck = fisher_yates_shuffle(seed);\n\n        // Step 2: Compute merkle root (for on-chain commitment)\n        let root = merkle_root(deck, seed);\n\n        // Step 3: Extract cards for gameplay\n        let cards = get_cards(deck);\n\n        // Verify: Re-compute and check consistency\n        let deck_verify = fisher_yates_shuffle(seed);\n        let root_verify = merkle_root(deck_verify, seed);\n        let cards_verify = get_cards(deck_verify);\n\n        assert(root == root_verify, \"Root should match on re-computation\");\n        for i in 0..CARDS_TO_DEAL {\n            assert(cards[i] == cards_verify[i], \"Cards should match on re-computation\");\n        }\n    }\n\n    // -------------------------------------------------------------------------\n    // Calculate Commitment Tests\n    // -------------------------------------------------------------------------\n\n    #[test]\n    fn test_calculate_commitment_is_deterministic() {\n        // Same inputs must produce the same commitments\n        let cards: [Field; 10] = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n        let players: [Field; 5] = [100, 200, 300, 400, 500];\n        let player_status: [bool; 5] = [true, true, true, true, true];\n\n        let commitments1 = calculate_commitment(cards, players, player_status);\n        let commitments2 = calculate_commitment(cards, players, player_status);\n\n        for i in 0..10 {\n            assert(commitments1[i] == commitments2[i], \"Commitments must be deterministic\");\n        }\n    }\n\n    #[test]\n    fn test_calculate_commitment_all_players_active() {\n        // When all players are active, all commitments should be non-zero\n        let cards: [Field; 10] = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n        let players: [Field; 5] = [100, 200, 300, 400, 500];\n        let player_status: [bool; 5] = [true, true, true, true, true];\n\n        let commitments = calculate_commitment(cards, players, player_status);\n\n        for i in 0..10 {\n            assert(commitments[i] != 0, \"Active player commitments should be non-zero\");\n        }\n    }\n\n    #[test]\n    fn test_calculate_commitment_all_players_inactive() {\n        // When all players are inactive, all commitments should be zero\n        let cards: [Field; 10] = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n        let players: [Field; 5] = [100, 200, 300, 400, 500];\n        let player_status: [bool; 5] = [false, false, false, false, false];\n\n        let commitments = calculate_commitment(cards, players, player_status);\n\n        for i in 0..10 {\n            assert(commitments[i] == 0, \"Inactive player commitments should be zero\");\n        }\n    }\n\n    #[test]\n    fn test_calculate_commitment_partial_players() {\n        // Mixed active/inactive players\n        let cards: [Field; 10] = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n        let players: [Field; 5] = [100, 200, 300, 400, 500];\n        // Players 0, 2, 4 are active; players 1, 3 are inactive\n        let player_status: [bool; 5] = [true, false, true, false, true];\n\n        let commitments = calculate_commitment(cards, players, player_status);\n\n        // Player 0 (cards 0, 1) - active\n        assert(commitments[0] != 0, \"Player 0 card 0 should have commitment\");\n        assert(commitments[1] != 0, \"Player 0 card 1 should have commitment\");\n\n        // Player 1 (cards 2, 3) - inactive\n        assert(commitments[2] == 0, \"Player 1 card 0 should be zero\");\n        assert(commitments[3] == 0, \"Player 1 card 1 should be zero\");\n\n        // Player 2 (cards 4, 5) - active\n        assert(commitments[4] != 0, \"Player 2 card 0 should have commitment\");\n        assert(commitments[5] != 0, \"Player 2 card 1 should have commitment\");\n\n        // Player 3 (cards 6, 7) - inactive\n        assert(commitments[6] == 0, \"Player 3 card 0 should be zero\");\n        assert(commitments[7] == 0, \"Player 3 card 1 should be zero\");\n\n        // Player 4 (cards 8, 9) - active\n        assert(commitments[8] != 0, \"Player 4 card 0 should have commitment\");\n        assert(commitments[9] != 0, \"Player 4 card 1 should have commitment\");\n    }\n\n    #[test]\n    fn test_calculate_commitment_card_player_mapping() {\n        // Verify that each pair of cards maps to the correct player\n        // Card 0,1 -> Player 0; Card 2,3 -> Player 1; etc.\n        let cards: [Field; 10] = [05, 10, 15, 20, 25, 30, 35, 40, 45, 50];\n        let players: [Field; 5] = [1, 2, 3, 4, 5];\n        let player_status: [bool; 5] = [true, true, true, true, true];\n\n        let commitments = calculate_commitment(cards, players, player_status);\n\n        // Manually verify the expected commitment hashes\n        // commitment[i] = Poseidon2::hash([cards[i], players[i/2]], 2)\n        let expected_0 = Poseidon2::hash([05, 1], 2); // card 0, player 0\n        let expected_1 = Poseidon2::hash([10, 1], 2); // card 1, player 0\n        let expected_2 = Poseidon2::hash([15, 2], 2); // card 2, player 1\n        let expected_3 = Poseidon2::hash([20, 2], 2); // card 3, player 1\n        let expected_4 = Poseidon2::hash([25, 3], 2); // card 4, player 2\n        let expected_5 = Poseidon2::hash([30, 3], 2); // card 5, player 2\n        let expected_6 = Poseidon2::hash([35, 4], 2); // card 6, player 3\n        let expected_7 = Poseidon2::hash([40, 4], 2); // card 7, player 3\n        let expected_8 = Poseidon2::hash([45, 5], 2); // card 8, player 4\n        let expected_9 = Poseidon2::hash([50, 5], 2); // card 9, player 4\n\n        assert(commitments[0] == expected_0, \"Card 0 commitment mismatch\");\n        assert(commitments[1] == expected_1, \"Card 1 commitment mismatch\");\n        assert(commitments[2] == expected_2, \"Card 2 commitment mismatch\");\n        assert(commitments[3] == expected_3, \"Card 3 commitment mismatch\");\n        assert(commitments[4] == expected_4, \"Card 4 commitment mismatch\");\n        assert(commitments[5] == expected_5, \"Card 5 commitment mismatch\");\n        assert(commitments[6] == expected_6, \"Card 6 commitment mismatch\");\n        assert(commitments[7] == expected_7, \"Card 7 commitment mismatch\");\n        assert(commitments[8] == expected_8, \"Card 8 commitment mismatch\");\n        assert(commitments[9] == expected_9, \"Card 9 commitment mismatch\");\n    }\n\n    #[test]\n    fn test_calculate_commitment_different_players_different_commitments() {\n        // Same card with different players should produce different commitments\n        let cards: [Field; 10] = [42, 42, 42, 42, 42, 42, 42, 42, 42, 42]; // all same card\n        let players: [Field; 5] = [1, 2, 3, 4, 5]; // different players\n        let player_status: [bool; 5] = [true, true, true, true, true];\n\n        let commitments = calculate_commitment(cards, players, player_status);\n\n        // Commitments for the same card but different players should differ\n        // Group by player: (0,1), (2,3), (4,5), (6,7), (8,9)\n        // Compare commitments across different player groups\n        assert(\n            commitments[0] != commitments[2],\n            \"Different players should have different commitments\",\n        );\n        assert(\n            commitments[2] != commitments[4],\n            \"Different players should have different commitments\",\n        );\n        assert(\n            commitments[4] != commitments[6],\n            \"Different players should have different commitments\",\n        );\n        assert(\n            commitments[6] != commitments[8],\n            \"Different players should have different commitments\",\n        );\n    }\n\n    #[test]\n    fn test_calculate_commitment_different_cards_same_player() {\n        // Different cards for the same player should produce different commitments\n        let cards: [Field; 10] = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]; // different cards\n        let players: [Field; 5] = [100, 100, 100, 100, 100]; // all same player\n        let player_status: [bool; 5] = [true, true, true, true, true];\n\n        let commitments = calculate_commitment(cards, players, player_status);\n\n        // Each card should produce a unique commitment\n        for i in 0..10 {\n            for j in (i + 1)..10 {\n                assert(\n                    commitments[i] != commitments[j],\n                    \"Different cards should have different commitments\",\n                );\n            }\n        }\n    }\n\n    #[test]\n    fn test_calculate_commitment_with_zero_values() {\n        // Edge case: zero-valued cards and players\n        let cards: [Field; 10] = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\n        let players: [Field; 5] = [0, 0, 0, 0, 0];\n        let player_status: [bool; 5] = [true, true, true, true, true];\n\n        let commitments = calculate_commitment(cards, players, player_status);\n\n        // All commitments should be the same since all inputs are identical\n        let expected = Poseidon2::hash([0, 0], 2);\n        for i in 0..10 {\n            assert(commitments[i] == expected, \"Zero values should still produce valid hash\");\n        }\n    }\n\n    #[test]\n    fn test_calculate_commitment_single_player_active() {\n        // Only one player is active\n        let cards: [Field; 10] = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n        let players: [Field; 5] = [100, 200, 300, 400, 500];\n        let player_status: [bool; 5] = [false, false, true, false, false]; // only player 2 active\n\n        let commitments = calculate_commitment(cards, players, player_status);\n\n        // Only cards 4 and 5 (belonging to player 2) should have commitments\n        assert(commitments[0] == 0, \"Player 0 should be inactive\");\n        assert(commitments[1] == 0, \"Player 0 should be inactive\");\n        assert(commitments[2] == 0, \"Player 1 should be inactive\");\n        assert(commitments[3] == 0, \"Player 1 should be inactive\");\n        assert(commitments[4] != 0, \"Player 2 card 0 should have commitment\");\n        assert(commitments[5] != 0, \"Player 2 card 1 should have commitment\");\n        assert(commitments[6] == 0, \"Player 3 should be inactive\");\n        assert(commitments[7] == 0, \"Player 3 should be inactive\");\n        assert(commitments[8] == 0, \"Player 4 should be inactive\");\n        assert(commitments[9] == 0, \"Player 4 should be inactive\");\n    }\n\n    // -------------------------------------------------------------------------\n    // Reveal Circuit Integration Test\n    // -------------------------------------------------------------------------\n\n    #[test]\n    fn test_commitment_verification_workflow() {\n        // Simulates the reveal circuit verification workflow\n        let cards: [Field; 10] = [5, 15, 25, 35, 45, 10, 20, 30, 40, 50];\n        let players: [Field; 5] = [0xAAA, 0xBBB, 0xCCC, 0xDDD, 0xEEE];\n        let player_status: [bool; 5] = [true, true, true, true, true];\n\n        // Step 1: Calculate commitments (done during deal phase)\n        let onchain_commitments = calculate_commitment(cards, players, player_status);\n\n        // Step 2: Later, recalculate commitments (done during reveal phase)\n        let reveal_commitments = calculate_commitment(cards, players, player_status);\n\n        // Step 3: Verify they match (as the reveal circuit would do)\n        for i in 0..player_status.len() {\n            if player_status[i] {\n                assert(\n                    reveal_commitments[2 * i] == onchain_commitments[2 * i],\n                    \"Card commitment mismatch at showdown\",\n                );\n                assert(\n                    reveal_commitments[2 * i + 1] == onchain_commitments[2 * i + 1],\n                    \"Card commitment mismatch at showdown for player\",\n                );\n            }\n        }\n    }\n\n    // -------------------------------------------------------------------------\n    // Calculate Community Commitment Tests\n    // -------------------------------------------------------------------------\n\n    #[test]\n    fn test_calculate_community_commitment_is_deterministic() {\n        // Same inputs must produce the same commitment\n        let cards: [Field; 5] = [10, 20, 30, 40, 50];\n\n        let commitment1 = calculate_community_commitment(cards);\n        let commitment2 = calculate_community_commitment(cards);\n\n        assert(commitment1 == commitment2, \"Community commitment must be deterministic\");\n    }\n\n    #[test]\n    fn test_calculate_community_commitment_different_cards() {\n        // Different community cards should produce different commitments\n        let cards1: [Field; 5] = [1, 2, 3, 4, 5];\n        let cards2: [Field; 5] = [6, 7, 8, 9, 10];\n\n        let commitment1 = calculate_community_commitment(cards1);\n        let commitment2 = calculate_community_commitment(cards2);\n\n        assert(commitment1 != commitment2, \"Different cards should produce different commitments\");\n    }\n\n    #[test]\n    fn test_calculate_community_commitment_order_matters() {\n        // The order of cards affects the commitment (important for flop, turn, river)\n        let cards1: [Field; 5] = [1, 2, 3, 4, 5];\n        let cards2: [Field; 5] = [5, 4, 3, 2, 1]; // reversed order\n\n        let commitment1 = calculate_community_commitment(cards1);\n        let commitment2 = calculate_community_commitment(cards2);\n\n        assert(commitment1 != commitment2, \"Card order should affect commitment\");\n    }\n\n    #[test]\n    fn test_calculate_community_commitment_integration_with_dealing() {\n        // Full workflow: shuffle -> get cards -> extract community cards -> commit\n        let seed: Field = 0xc0ffee;\n        let deck = fisher_yates_shuffle(seed);\n        let dealt_cards = get_cards(deck);\n\n        // Community cards are the last 5 of the 15 dealt cards (indices 10-14)\n        let community_cards: [Field; 5] =\n            [dealt_cards[10], dealt_cards[11], dealt_cards[12], dealt_cards[13], dealt_cards[14]];\n\n        // Calculate commitment\n        let commitment1 = calculate_community_commitment(community_cards);\n\n        // Re-run the entire workflow for verification\n        let deck_verify = fisher_yates_shuffle(seed);\n        let dealt_verify = get_cards(deck_verify);\n        let community_verify: [Field; 5] = [\n            dealt_verify[10],\n            dealt_verify[11],\n            dealt_verify[12],\n            dealt_verify[13],\n            dealt_verify[14],\n        ];\n        let commitment2 = calculate_community_commitment(community_verify);\n\n        assert(commitment1 == commitment2, \"Community commitment should be reproducible from seed\");\n    }\n\n    #[test]\n    fn test_calculate_community_commitment_unique_for_different_deals() {\n        // Different shuffles should produce different community commitments\n        let deck1 = fisher_yates_shuffle(111);\n        let deck2 = fisher_yates_shuffle(222);\n\n        let cards1 = get_cards(deck1);\n        let cards2 = get_cards(deck2);\n\n        let community1: [Field; 5] = [cards1[10], cards1[11], cards1[12], cards1[13], cards1[14]];\n        let community2: [Field; 5] = [cards2[10], cards2[11], cards2[12], cards2[13], cards2[14]];\n\n        let commitment1 = calculate_community_commitment(community1);\n        let commitment2 = calculate_community_commitment(community2);\n\n        assert(\n            commitment1 != commitment2,\n            \"Different shuffles should produce different community commitments\",\n        );\n    }\n}\n","path":"/home/ally/DevEnv/pvtDock/KH/poker-solana/backend/src/services/circuitry/assist/src/lib.nr"},"59":{"source":"use std::default::Default;\nuse std::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        self.state[0] += self.cache[0];\n        self.state[1] += self.cache[1];\n        self.state[2] += self.cache[2];\n        self.state = crate::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut state = [0; 4];\n        state[RATE] = iv;\n\n        if std::runtime::is_unconstrained() {\n            for i in 0..(in_len / RATE) {\n                state[0] += input[i * RATE];\n                state[1] += input[i * RATE + 1];\n                state[2] += input[i * RATE + 2];\n                state = crate::poseidon2_permutation(state, 4);\n            }\n\n            // handle remaining elements after last full RATE-sized chunk\n            let remainder_start = (in_len / RATE) * RATE;\n            for j in remainder_start..in_len {\n                state[j - remainder_start] += input[j];\n            }\n        } else {\n            let mut states: [[Field; 4]; N / RATE + 1] = [[0; 4]; N / RATE + 1];\n            states[0] = state;\n\n            // process all full RATE-sized chunks, storing state after each permutation\n            for chunk_idx in 0..(N / RATE) {\n                for i in 0..RATE {\n                    state[i] += input[chunk_idx * RATE + i];\n                }\n                state = crate::poseidon2_permutation(state, 4);\n                states[chunk_idx + 1] = state;\n            }\n\n            // get state at the last full block before in_len\n            let first_partially_filled_chunk = in_len / RATE;\n            state = states[first_partially_filled_chunk];\n\n            // handle remaining elements after last full RATE-sized chunk\n            let remainder_start = (in_len / RATE) * RATE;\n            for j in 0..RATE {\n                let idx = remainder_start + j;\n                if idx < in_len {\n                    state[j] += input[idx];\n                }\n            }\n        }\n\n        // always run final permutation unless we just completed a full chunk\n        // still need to permute once if in_len is 0\n        if (in_len == 0) | (in_len % RATE != 0) {\n            state = crate::poseidon2_permutation(state, 4)\n        };\n\n        state[0]\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n","path":"/home/ally/nargo/github.com/noir-lang/poseidon/v0.2.2/src/poseidon2.nr"}}};

export async function calculate_commitment(cards: Field[], players: Field[], player_status: boolean[], foreignCallHandler?: ForeignCallHandler): Promise<Field[]> {
  const program = new Noir(calculate_commitment_circuit);
  const args: InputMap = { cards, players, player_status };
  const { returnValue } = await program.execute(args, foreignCallHandler);
  return returnValue as Field[];
}
export type calculate_community_commitmentInputType = {
  cards: Field[];
}

export type calculate_community_commitmentReturnType = Field;
export const calculate_community_commitment_circuit: CompiledCircuit = {"abi":{"parameters":[{"name":"cards","type":{"kind":"array","length":5,"type":{"kind":"field"}},"visibility":"private"}],"return_type":{"abi_type":{"kind":"field"},"visibility":"private"},"error_types":{}},"bytecode":"H4sIAAAAAAAA/5VSuwrCMBRN7Pul/QLpqJviJ4jgJI4uIqV2KLRVJB069hPEH/ArRD+nm6OLu1FTmkbR5MDhhMvh5N7kQvBGl2jgx0EW+yhcBZskydII5a9ThJIwRS52qOATkKhHdLCe7crhsX+eT05FsVj2Rtdpftnux+X9cCMZHvgJhc62MWXQvAtSbBFVKZ+GqWMamCYTLjH9/gGUBLwa4H8Hiz+3AdH+ZQGvDvj7t/lzv/6jRdWfahA1KZ+D2cbsYLpMZouoB/haUARmc/hz62UF9T5K1AxVnfVWeAAnO1w1hgMAAA==","debug_symbols":"tZTfioQgFMbfxesu8m86r7IsYWWDIBZOLSzRu681mXUhDMJeferx+53DUc4COtXMz1rbfniBx9cCGqeN0c/aDK2c9GD96bIWIGzrySnlj8Al7l2jdMpO4GFnYwrwI828X3qN0u46SeejZQGU7bx6YK+N2lZrEd1l2spEKQ43E7A6ARR+ToCRgPIIKBJwHgFHAskjkEigWQQu0ElgKEVgaQKmAYDFpQJx81dpP+KsOgCIVzSHIGj4S0hwniKINIFwSA8C4TR2AX5cAyYivASmZU4fbgQEcwjV2UnMy2QnIf7XRnDEziIwuRXx7Xey1e42TkDp8f794FuQF1IA/Bayybplc1o2Rh3zp59texlH0+8YImFgjW5oVTc7teXaYz77Hw==","file_map":{"19":{"source":"// Exposed only for usage in `std::meta`\npub(crate) mod poseidon2;\n\nuse crate::default::Default;\nuse crate::embedded_curve_ops::{\n    EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_array_return,\n};\nuse crate::meta::derive_via;\n\n#[foreign(sha256_compression)]\n// docs:start:sha256_compression\npub fn sha256_compression(input: [u32; 16], state: [u32; 8]) -> [u32; 8] {}\n// docs:end:sha256_compression\n\n#[foreign(keccakf1600)]\n// docs:start:keccakf1600\npub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {}\n// docs:end:keccakf1600\n\npub mod keccak {\n    #[deprecated(\"This function has been moved to std::hash::keccakf1600\")]\n    pub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {\n        super::keccakf1600(input)\n    }\n}\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{\n    if crate::runtime::is_unconstrained() {\n        // Temporary measure while Barretenberg is main proving system.\n        // Please open an issue if you're working on another proving system and running into problems due to this.\n        crate::static_assert(\n            N <= 1024,\n            \"Barretenberg cannot prove blake3 hashes with inputs larger than 1024 bytes\",\n        );\n    }\n    __blake3(input)\n}\n\n#[foreign(blake3)]\nfn __blake3<let N: u32>(input: [u8; N]) -> [u8; 32] {}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\n#[inline_always]\npub fn pedersen_commitment_with_separator<let N: u32>(\n    input: [Field; N],\n    separator: u32,\n) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        // we use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        points[i] = from_field_unsafe(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    multi_scalar_mul(generators, points)\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[no_predicates]\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let mut scalars: [EmbeddedCurveScalar; N + 1] = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N + 1];\n    let mut generators: [EmbeddedCurvePoint; N + 1] =\n        [EmbeddedCurvePoint::point_at_infinity(); N + 1];\n    let domain_generators: [EmbeddedCurvePoint; N] =\n        derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n\n    for i in 0..N {\n        scalars[i] = from_field_unsafe(input[i]);\n        generators[i] = domain_generators[i];\n    }\n    scalars[N] = EmbeddedCurveScalar { lo: N as Field, hi: 0 as Field };\n\n    let length_generator: [EmbeddedCurvePoint; 1] =\n        derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    generators[N] = length_generator[0];\n    multi_scalar_mul_array_return(generators, scalars, true)[0].x\n}\n\n#[field(bn254)]\n#[inline_always]\npub fn derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    // TODO(https://github.com/noir-lang/noir/issues/5672): Add back assert_constant on starting_index\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {}\n\n#[field(bn254)]\n// Decompose the input 'bn254 scalar' into two 128 bits limbs.\n// It is called 'unsafe' because it does not assert the limbs are 128 bits\n// Assuming the limbs are 128 bits:\n// Assert the decomposition does not overflow the field size.\nfn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {\n    // Safety: xlo and xhi decomposition is checked below\n    let (xlo, xhi) = unsafe { crate::field::bn254::decompose_hint(scalar) };\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);\n    // Check that the decomposition does not overflow the field size\n    let (a, b) = if xhi == crate::field::bn254::PHI {\n        (xlo, crate::field::bn254::PLO)\n    } else {\n        (xhi, crate::field::bn254::PHI)\n    };\n    crate::field::bn254::assert_lt(a, b);\n\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n\npub fn poseidon2_permutation<let N: u32>(input: [Field; N], state_len: u32) -> [Field; N] {\n    assert_eq(input.len(), state_len);\n    poseidon2_permutation_internal(input)\n}\n\n#[foreign(poseidon2_permutation)]\nfn poseidon2_permutation_internal<let N: u32>(input: [Field; N]) -> [Field; N] {}\n\n// Generic hashing support.\n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\n#[derive_via(derive_hash)]\npub trait Hash {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher;\n}\n\n// docs:start:derive_hash\ncomptime fn derive_hash(s: TypeDefinition) -> Quoted {\n    let name = quote { $crate::hash::Hash };\n    let signature = quote { fn hash<H>(_self: Self, _state: &mut H) where H: $crate::hash::Hasher };\n    let for_each_field = |name| quote { _self.$name.hash(_state); };\n    crate::meta::make_trait_impl(\n        s,\n        name,\n        signature,\n        for_each_field,\n        quote {},\n        |fields| fields,\n    )\n}\n// docs:end:derive_hash\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\npub trait Hasher {\n    fn finish(self) -> Field;\n\n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\npub trait BuildHasher {\n    type H: Hasher;\n\n    fn build_hasher(self) -> H;\n}\n\npub struct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    type H = H;\n\n    fn build_hasher(_self: Self) -> H {\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn default() -> Self {\n        BuildHasherDefault {}\n    }\n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u1 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u128 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u8 as Field);\n    }\n}\n\nimpl Hash for i16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u16 as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u32 as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u64 as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H)\n    where\n        H: Hasher,\n    {}\n}\n\nimpl<T, let N: u32> Hash for [T; N]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B)\nwhere\n    A: Hash,\n    B: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n    E: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n// Some test vectors for Pedersen hash and Pedersen Commitment.\n// They have been generated using the same functions so the tests are for now useless\n// but they will be useful when we switch to Noir implementation.\n#[test]\nfn assert_pedersen() {\n    assert_eq(\n        pedersen_hash_with_separator([1], 1),\n        0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1], 1),\n        EmbeddedCurvePoint {\n            x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,\n            y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,\n            is_infinite: false,\n        },\n    );\n\n    assert_eq(\n        pedersen_hash_with_separator([1, 2], 2),\n        0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2], 2),\n        EmbeddedCurvePoint {\n            x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,\n            y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3], 3),\n        0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3], 3),\n        EmbeddedCurvePoint {\n            x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,\n            y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4], 4),\n        0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4], 4),\n        EmbeddedCurvePoint {\n            x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,\n            y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5),\n        0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5),\n        EmbeddedCurvePoint {\n            x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,\n            y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6),\n        0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6),\n        EmbeddedCurvePoint {\n            x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,\n            y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        EmbeddedCurvePoint {\n            x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,\n            y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        EmbeddedCurvePoint {\n            x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,\n            y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        EmbeddedCurvePoint {\n            x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,\n            y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        EmbeddedCurvePoint {\n            x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,\n            y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,\n            is_infinite: false,\n        },\n    );\n}\n","path":"std/hash/mod.nr"},"51":{"source":"use poseidon::poseidon2::Poseidon2;\nuse std::field::bn254::assert_lt;\n\n/// Number of cards in a standard deck.\npub global DECK_SIZE: u32 = 52;\n\n/// Number of cards to deal for gameplay (5 players * 2 cards + 5 community cards = 15).\npub global CARDS_TO_DEAL: u32 = 15;\n\n// Domain separators prevent cross-protocol hash collisions.\npub global HASH_DOMAIN_SEPARATOR_SEED: Field = 1;\npub global HASH_DOMAIN_SEPARATOR_DECK: Field = 2;\npub global HASH_DOMAIN_SEPARATOR_CARD: Field = 3;\n\n/// Domain separator for Fisher-Yates RNG state transitions.\npub global HASH_DOMAIN_SEPARATOR_RNG: Field = 4;\npub global PADDING_NONCE: Field = 5;\n\n/// Performs a deterministic Fisher-Yates shuffle on a 52-card deck.\n///\n/// # Arguments\n/// * `seed` - Random seed from on-chain randomness source.\n///\n/// # Returns\n/// A shuffled deck represented as an array of Field elements (0-51).\n///\n/// # Security Properties\n/// - Deterministic: Same seed always produces the same shuffle.\n/// - Uniform: Each permutation is equally likely given a uniformly random seed.\n/// - Verifiable: The shuffle can be independently verified with the seed.\n#[export]\npub fn fisher_yates_shuffle(seed: Field) -> [Field; DECK_SIZE] {\n    // Initialize the deck as 0-51 indices\n    let mut deck = [0; DECK_SIZE];\n    for i in 0..DECK_SIZE {\n        deck[i] = i as Field;\n    }\n\n    // Initialize the RNG state with the random seed using domain separator\n    let mut rng_state = Poseidon2::hash([HASH_DOMAIN_SEPARATOR_RNG, seed], 2);\n\n    // Perform the Fisher-Yates shuffle\n    // Iterate from the last element down to the second element\n    for i in 0..(DECK_SIZE - 1) {\n        let idx = (DECK_SIZE - 1) - i;\n\n        // Generate random hash with domain-separated RNG state update\n        rng_state = Poseidon2::hash([HASH_DOMAIN_SEPARATOR_RNG, rng_state, idx as Field], 3);\n\n        // Calculate the swap index unconstrained\n        let range = (idx + 1) as Field;\n        // Safety: constraints enabled by proceeding assertions\n        let (quotient, remainder) = unsafe { divide_hint(rng_state, range) };\n\n        // Constrain the division result: rng_state = quotient * range + remainder\n        assert(rng_state == quotient * range + remainder);\n        // Ensure remainder is in valid range [0, range)\n        assert_lt(remainder, range);\n\n        let swap_idx = remainder as u32;\n\n        // Perform the swap\n        if swap_idx != idx {\n            let temp = deck[idx];\n            deck[idx] = deck[swap_idx];\n            deck[swap_idx] = temp;\n        }\n    }\n\n    deck\n}\n\n/// Unconstrained hint for field division.\n/// Computes (quotient, remainder) such that numerator = quotient * denominator + remainder.\nunconstrained fn divide_hint(numerator: Field, denominator: Field) -> (Field, Field) {\n    // NOTE: assuming denominator is small enough to fit in u32 (as is the case for a DECK_SIZE of 52)\n    let den_u64 = denominator as u64;\n    // Minimal check to avoid division by zero\n    assert(den_u64 != 0);\n    // Ensure denominator fits in u32 to guarantee 'remainder * 256' fits in u64\n    assert(den_u64 <= 4294967295);\n\n    let bytes: [u8; 32] = numerator.to_be_bytes();\n    let mut remainder: u64 = 0;\n    let mut quotient: Field = 0;\n\n    for i in 0..32 {\n        let b = bytes[i] as u64;\n        let val = remainder * 256 + b;\n        let q_digit = val / den_u64;\n        let r_digit = val % den_u64;\n\n        quotient = quotient * 256 + (q_digit as Field);\n        remainder = r_digit;\n    }\n    (quotient, remainder as Field)\n}\n\n/// Computes the Merkle root of a shuffled deck.\n///\n/// # Arguments\n/// * `deck` - The shuffled deck array.\n/// * `seed` - The shuffle seed (used to derive salt for binding).\n///\n/// # Returns\n/// The Merkle root hash of the deck.\n///\n/// # Implementation Notes\n/// - Uses a 64-leaf tree (52 cards + 12 padding leaves).\n/// - Each card is hashed with its position and a seed-derived salt.\n#[export]\npub fn merkle_root(deck: [Field; DECK_SIZE], seed: Field) -> Field {\n    // Generate salt for binding cards to this specific shuffle\n    let salt = derive_salt(seed);\n\n    // Hash all cards directly into buffer\n    let mut buffer: [Field; 64] = [0; 64];\n\n    for i in 0..DECK_SIZE {\n        buffer[i] = hash_card_in_deck(deck[i], i as Field, salt);\n    }\n\n    // Pad buffer with a fixed value to reach power of 2 tree size\n    let padding = Poseidon2::hash([HASH_DOMAIN_SEPARATOR_DECK, PADDING_NONCE], 2);\n    for i in DECK_SIZE..64 {\n        buffer[i] = padding;\n    }\n\n    // Build tree bottom-up, reusing buffer space\n    // After each level, results are stored in the first half of the buffer\n    let mut size = 64;\n    for _ in 0..6 {\n        let next_size = size / 2;\n        for i in 0..next_size {\n            buffer[i] = merkle_a_pair(buffer[i * 2], buffer[i * 2 + 1]);\n        }\n        size = next_size;\n    }\n\n    buffer[0]\n}\n\n/// Derives a salt from the shuffle seed for card hashing.\npub fn derive_salt(seed: Field) -> Field {\n    Poseidon2::hash([seed, HASH_DOMAIN_SEPARATOR_CARD], 2)\n}\n\n/// Hashes a card at a specific position with salt.\n/// The position ensures uniqueness even for duplicate card values.\npub fn hash_card_in_deck(card: Field, position: Field, salt: Field) -> Field {\n    Poseidon2::hash([HASH_DOMAIN_SEPARATOR_CARD, card, position, salt], 4)\n}\n\n/// Hashes two child nodes to produce a parent node in the Merkle tree.\npub fn merkle_a_pair(left: Field, right: Field) -> Field {\n    Poseidon2::hash([left, right], 2)\n}\n\n/// Extracts the first CARDS_TO_DEAL cards from the shuffled deck.\n///\n/// # Arguments\n/// * `deck` - The shuffled deck array.\n///\n/// # Returns\n/// An array of the first 15 cards for gameplay.\n#[export]\npub fn get_cards(deck: [Field; DECK_SIZE]) -> [Field; CARDS_TO_DEAL] {\n    let mut cards = [0; CARDS_TO_DEAL];\n    for i in 0..CARDS_TO_DEAL {\n        cards[i] = deck[i];\n    }\n    cards\n}\n\n/// Commitments of card allocations to respective players\n///\n/// # Arguments\n/// * `cards` - The cards array.\n/// * `players` - The players array.\n/// * `player_status` - The player status array - if player is not in the game, commitment is 0\n///\n/// # Returns\n/// An array of commitments for the cards.\n#[export]\npub fn calculate_commitment(\n    cards: [Field; 10],\n    players: [Field; 5],\n    player_status: [bool; 5],\n) -> [Field; 10] {\n    let mut commitments: [Field; 10] = [0; 10];\n    let mut k = 0;\n\n    for i in 0..cards.len() {\n        let player: Field = players[k];\n\n        commitments[i] = if player_status[k] {\n            Poseidon2::hash([cards[i], player], 2)\n        } else {\n            0\n        };\n\n        if (i % 2 != 0) {\n            k += 1;\n        }\n    }\n\n    commitments\n}\n\n/// Commitment of community cards\n///\n/// # Arguments\n/// * `cards` - The cards array.\n///\n/// # Returns\n/// The commitment for the community cards.\n#[export]\npub fn calculate_community_commitment(cards: [Field; 5]) -> Field {\n    Poseidon2::hash([cards[0], cards[1], cards[2], cards[3], cards[4]], 5)\n}\n\n// =============================================================================\n// Test Module\n// =============================================================================\n\nmod tests {\n    use super::{\n        calculate_commitment, calculate_community_commitment, CARDS_TO_DEAL, DECK_SIZE, derive_salt,\n        fisher_yates_shuffle, get_cards, hash_card_in_deck, merkle_a_pair, merkle_root,\n    };\n    use poseidon::poseidon2::Poseidon2;\n\n    // -------------------------------------------------------------------------\n    // Fisher-Yates Shuffle Tests\n    // -------------------------------------------------------------------------\n\n    #[test]\n    fn test_shuffle_produces_valid_permutation() {\n        // A valid permutation contains each card exactly once\n        let seed: Field = 12345;\n        let deck = fisher_yates_shuffle(seed);\n\n        // Check that all cards 0-51 appear exactly once\n        let mut card_count: [u32; DECK_SIZE] = [0; DECK_SIZE];\n        for i in 0..DECK_SIZE {\n            let card_idx = deck[i] as u32;\n            assert(card_idx < DECK_SIZE, \"Card index out of bounds\");\n            card_count[card_idx] += 1;\n        }\n\n        for i in 0..DECK_SIZE {\n            assert(card_count[i] == 1, \"Each card must appear exactly once\");\n        }\n    }\n\n    #[test]\n    fn test_shuffle_is_deterministic() {\n        // Same seed must produce the same shuffle\n        let seed: Field = 0xabcdef123456;\n        let deck1 = fisher_yates_shuffle(seed);\n        let deck2 = fisher_yates_shuffle(seed);\n\n        for i in 0..DECK_SIZE {\n            assert(deck1[i] == deck2[i], \"Shuffle must be deterministic\");\n        }\n    }\n\n    #[test]\n    fn test_shuffle_different_seeds_produce_different_decks() {\n        let deck1 = fisher_yates_shuffle(1);\n        let deck2 = fisher_yates_shuffle(2);\n\n        // At least one card should be in a different position\n        let mut has_difference = false;\n        for i in 0..DECK_SIZE {\n            if deck1[i] != deck2[i] {\n                has_difference = true;\n            }\n        }\n        assert(has_difference, \"Different seeds should produce different shuffles\");\n    }\n\n    #[test]\n    fn test_shuffle_with_zero_seed() {\n        // Zero seed should still produce a valid permutation\n        let deck = fisher_yates_shuffle(0);\n\n        let mut card_count: [u32; DECK_SIZE] = [0; DECK_SIZE];\n        for i in 0..DECK_SIZE {\n            let card_idx = deck[i] as u32;\n            card_count[card_idx] += 1;\n        }\n\n        for i in 0..DECK_SIZE {\n            assert(card_count[i] == 1, \"Each card must appear exactly once\");\n        }\n    }\n\n    // -------------------------------------------------------------------------\n    // Merkle Root Tests\n    // -------------------------------------------------------------------------\n\n    #[test]\n    fn test_merkle_root_is_deterministic() {\n        let seed: Field = 42;\n        let deck = fisher_yates_shuffle(seed);\n\n        let root1 = merkle_root(deck, seed);\n        let root2 = merkle_root(deck, seed);\n\n        assert(root1 == root2, \"Merkle root must be deterministic\");\n    }\n\n    #[test]\n    fn test_merkle_root_different_decks_produce_different_roots() {\n        let deck1 = fisher_yates_shuffle(100);\n        let deck2 = fisher_yates_shuffle(200);\n\n        let root1 = merkle_root(deck1, 100);\n        let root2 = merkle_root(deck2, 200);\n\n        assert(root1 != root2, \"Different decks should produce different roots\");\n    }\n\n    #[test]\n    fn test_merkle_root_same_deck_different_seed_produces_different_root() {\n        // The seed affects the salt, so same deck with different seeds = different roots\n        let deck = fisher_yates_shuffle(123);\n\n        let root1 = merkle_root(deck, 123);\n        let root2 = merkle_root(deck, 456);\n\n        assert(root1 != root2, \"Same deck with different seeds should produce different roots\");\n    }\n\n    // -------------------------------------------------------------------------\n    // Helper Function Tests\n    // -------------------------------------------------------------------------\n\n    #[test]\n    fn test_derive_salt_is_deterministic() {\n        let seed: Field = 999;\n        let salt1 = derive_salt(seed);\n        let salt2 = derive_salt(seed);\n\n        assert(salt1 == salt2, \"derive_salt must be deterministic\");\n    }\n\n    #[test]\n    fn test_derive_salt_different_seeds_produce_different_salts() {\n        let salt1 = derive_salt(1);\n        let salt2 = derive_salt(2);\n\n        assert(salt1 != salt2, \"Different seeds should produce different salts\");\n    }\n\n    #[test]\n    fn test_hash_card_is_deterministic() {\n        let card: Field = 10;\n        let position: Field = 5;\n        let salt: Field = 12345;\n\n        let hash1 = hash_card_in_deck(card, position, salt);\n        let hash2 = hash_card_in_deck(card, position, salt);\n\n        assert(hash1 == hash2, \"hash_card_in_deck must be deterministic\");\n    }\n\n    #[test]\n    fn test_hash_card_position_affects_hash() {\n        let card: Field = 10;\n        let salt: Field = 12345;\n\n        let hash1 = hash_card_in_deck(card, 0, salt);\n        let hash2 = hash_card_in_deck(card, 1, salt);\n\n        assert(hash1 != hash2, \"Different positions should produce different hashes\");\n    }\n\n    #[test]\n    fn test_merkle_pair_is_deterministic() {\n        let left: Field = 111;\n        let right: Field = 222;\n\n        let hash1 = merkle_a_pair(left, right);\n        let hash2 = merkle_a_pair(left, right);\n\n        assert(hash1 == hash2, \"merkle_a_pair must be deterministic\");\n    }\n\n    #[test]\n    fn test_merkle_pair_order_matters() {\n        let a: Field = 111;\n        let b: Field = 222;\n\n        let hash1 = merkle_a_pair(a, b);\n        let hash2 = merkle_a_pair(b, a);\n\n        assert(hash1 != hash2, \"merkle_a_pair should be order-sensitive\");\n    }\n\n    // -------------------------------------------------------------------------\n    // Card Selection Tests\n    // -------------------------------------------------------------------------\n\n    #[test]\n    fn test_get_cards_extracts_first_fifteen() {\n        let deck = fisher_yates_shuffle(777);\n        let cards = get_cards(deck);\n\n        for i in 0..CARDS_TO_DEAL {\n            assert(cards[i] == deck[i], \"get_cards should extract cards in order\");\n        }\n    }\n\n    #[test]\n    fn test_get_cards_returns_correct_count() {\n        let deck = fisher_yates_shuffle(888);\n        let cards = get_cards(deck);\n\n        // Verify we get exactly CARDS_TO_DEAL cards\n        assert(cards.len() == CARDS_TO_DEAL, \"Should return CARDS_TO_DEAL cards\");\n    }\n\n    // -------------------------------------------------------------------------\n    // Integration Tests\n    // -------------------------------------------------------------------------\n\n    #[test]\n    fn test_full_shuffle_and_verify_workflow() {\n        // Simulate the full workflow: shuffle, compute root, extract cards\n        let seed: Field = 0xdeadbeef;\n\n        // Step 1: Shuffle\n        let deck = fisher_yates_shuffle(seed);\n\n        // Step 2: Compute merkle root (for on-chain commitment)\n        let root = merkle_root(deck, seed);\n\n        // Step 3: Extract cards for gameplay\n        let cards = get_cards(deck);\n\n        // Verify: Re-compute and check consistency\n        let deck_verify = fisher_yates_shuffle(seed);\n        let root_verify = merkle_root(deck_verify, seed);\n        let cards_verify = get_cards(deck_verify);\n\n        assert(root == root_verify, \"Root should match on re-computation\");\n        for i in 0..CARDS_TO_DEAL {\n            assert(cards[i] == cards_verify[i], \"Cards should match on re-computation\");\n        }\n    }\n\n    // -------------------------------------------------------------------------\n    // Calculate Commitment Tests\n    // -------------------------------------------------------------------------\n\n    #[test]\n    fn test_calculate_commitment_is_deterministic() {\n        // Same inputs must produce the same commitments\n        let cards: [Field; 10] = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n        let players: [Field; 5] = [100, 200, 300, 400, 500];\n        let player_status: [bool; 5] = [true, true, true, true, true];\n\n        let commitments1 = calculate_commitment(cards, players, player_status);\n        let commitments2 = calculate_commitment(cards, players, player_status);\n\n        for i in 0..10 {\n            assert(commitments1[i] == commitments2[i], \"Commitments must be deterministic\");\n        }\n    }\n\n    #[test]\n    fn test_calculate_commitment_all_players_active() {\n        // When all players are active, all commitments should be non-zero\n        let cards: [Field; 10] = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n        let players: [Field; 5] = [100, 200, 300, 400, 500];\n        let player_status: [bool; 5] = [true, true, true, true, true];\n\n        let commitments = calculate_commitment(cards, players, player_status);\n\n        for i in 0..10 {\n            assert(commitments[i] != 0, \"Active player commitments should be non-zero\");\n        }\n    }\n\n    #[test]\n    fn test_calculate_commitment_all_players_inactive() {\n        // When all players are inactive, all commitments should be zero\n        let cards: [Field; 10] = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n        let players: [Field; 5] = [100, 200, 300, 400, 500];\n        let player_status: [bool; 5] = [false, false, false, false, false];\n\n        let commitments = calculate_commitment(cards, players, player_status);\n\n        for i in 0..10 {\n            assert(commitments[i] == 0, \"Inactive player commitments should be zero\");\n        }\n    }\n\n    #[test]\n    fn test_calculate_commitment_partial_players() {\n        // Mixed active/inactive players\n        let cards: [Field; 10] = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n        let players: [Field; 5] = [100, 200, 300, 400, 500];\n        // Players 0, 2, 4 are active; players 1, 3 are inactive\n        let player_status: [bool; 5] = [true, false, true, false, true];\n\n        let commitments = calculate_commitment(cards, players, player_status);\n\n        // Player 0 (cards 0, 1) - active\n        assert(commitments[0] != 0, \"Player 0 card 0 should have commitment\");\n        assert(commitments[1] != 0, \"Player 0 card 1 should have commitment\");\n\n        // Player 1 (cards 2, 3) - inactive\n        assert(commitments[2] == 0, \"Player 1 card 0 should be zero\");\n        assert(commitments[3] == 0, \"Player 1 card 1 should be zero\");\n\n        // Player 2 (cards 4, 5) - active\n        assert(commitments[4] != 0, \"Player 2 card 0 should have commitment\");\n        assert(commitments[5] != 0, \"Player 2 card 1 should have commitment\");\n\n        // Player 3 (cards 6, 7) - inactive\n        assert(commitments[6] == 0, \"Player 3 card 0 should be zero\");\n        assert(commitments[7] == 0, \"Player 3 card 1 should be zero\");\n\n        // Player 4 (cards 8, 9) - active\n        assert(commitments[8] != 0, \"Player 4 card 0 should have commitment\");\n        assert(commitments[9] != 0, \"Player 4 card 1 should have commitment\");\n    }\n\n    #[test]\n    fn test_calculate_commitment_card_player_mapping() {\n        // Verify that each pair of cards maps to the correct player\n        // Card 0,1 -> Player 0; Card 2,3 -> Player 1; etc.\n        let cards: [Field; 10] = [05, 10, 15, 20, 25, 30, 35, 40, 45, 50];\n        let players: [Field; 5] = [1, 2, 3, 4, 5];\n        let player_status: [bool; 5] = [true, true, true, true, true];\n\n        let commitments = calculate_commitment(cards, players, player_status);\n\n        // Manually verify the expected commitment hashes\n        // commitment[i] = Poseidon2::hash([cards[i], players[i/2]], 2)\n        let expected_0 = Poseidon2::hash([05, 1], 2); // card 0, player 0\n        let expected_1 = Poseidon2::hash([10, 1], 2); // card 1, player 0\n        let expected_2 = Poseidon2::hash([15, 2], 2); // card 2, player 1\n        let expected_3 = Poseidon2::hash([20, 2], 2); // card 3, player 1\n        let expected_4 = Poseidon2::hash([25, 3], 2); // card 4, player 2\n        let expected_5 = Poseidon2::hash([30, 3], 2); // card 5, player 2\n        let expected_6 = Poseidon2::hash([35, 4], 2); // card 6, player 3\n        let expected_7 = Poseidon2::hash([40, 4], 2); // card 7, player 3\n        let expected_8 = Poseidon2::hash([45, 5], 2); // card 8, player 4\n        let expected_9 = Poseidon2::hash([50, 5], 2); // card 9, player 4\n\n        assert(commitments[0] == expected_0, \"Card 0 commitment mismatch\");\n        assert(commitments[1] == expected_1, \"Card 1 commitment mismatch\");\n        assert(commitments[2] == expected_2, \"Card 2 commitment mismatch\");\n        assert(commitments[3] == expected_3, \"Card 3 commitment mismatch\");\n        assert(commitments[4] == expected_4, \"Card 4 commitment mismatch\");\n        assert(commitments[5] == expected_5, \"Card 5 commitment mismatch\");\n        assert(commitments[6] == expected_6, \"Card 6 commitment mismatch\");\n        assert(commitments[7] == expected_7, \"Card 7 commitment mismatch\");\n        assert(commitments[8] == expected_8, \"Card 8 commitment mismatch\");\n        assert(commitments[9] == expected_9, \"Card 9 commitment mismatch\");\n    }\n\n    #[test]\n    fn test_calculate_commitment_different_players_different_commitments() {\n        // Same card with different players should produce different commitments\n        let cards: [Field; 10] = [42, 42, 42, 42, 42, 42, 42, 42, 42, 42]; // all same card\n        let players: [Field; 5] = [1, 2, 3, 4, 5]; // different players\n        let player_status: [bool; 5] = [true, true, true, true, true];\n\n        let commitments = calculate_commitment(cards, players, player_status);\n\n        // Commitments for the same card but different players should differ\n        // Group by player: (0,1), (2,3), (4,5), (6,7), (8,9)\n        // Compare commitments across different player groups\n        assert(\n            commitments[0] != commitments[2],\n            \"Different players should have different commitments\",\n        );\n        assert(\n            commitments[2] != commitments[4],\n            \"Different players should have different commitments\",\n        );\n        assert(\n            commitments[4] != commitments[6],\n            \"Different players should have different commitments\",\n        );\n        assert(\n            commitments[6] != commitments[8],\n            \"Different players should have different commitments\",\n        );\n    }\n\n    #[test]\n    fn test_calculate_commitment_different_cards_same_player() {\n        // Different cards for the same player should produce different commitments\n        let cards: [Field; 10] = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]; // different cards\n        let players: [Field; 5] = [100, 100, 100, 100, 100]; // all same player\n        let player_status: [bool; 5] = [true, true, true, true, true];\n\n        let commitments = calculate_commitment(cards, players, player_status);\n\n        // Each card should produce a unique commitment\n        for i in 0..10 {\n            for j in (i + 1)..10 {\n                assert(\n                    commitments[i] != commitments[j],\n                    \"Different cards should have different commitments\",\n                );\n            }\n        }\n    }\n\n    #[test]\n    fn test_calculate_commitment_with_zero_values() {\n        // Edge case: zero-valued cards and players\n        let cards: [Field; 10] = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\n        let players: [Field; 5] = [0, 0, 0, 0, 0];\n        let player_status: [bool; 5] = [true, true, true, true, true];\n\n        let commitments = calculate_commitment(cards, players, player_status);\n\n        // All commitments should be the same since all inputs are identical\n        let expected = Poseidon2::hash([0, 0], 2);\n        for i in 0..10 {\n            assert(commitments[i] == expected, \"Zero values should still produce valid hash\");\n        }\n    }\n\n    #[test]\n    fn test_calculate_commitment_single_player_active() {\n        // Only one player is active\n        let cards: [Field; 10] = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n        let players: [Field; 5] = [100, 200, 300, 400, 500];\n        let player_status: [bool; 5] = [false, false, true, false, false]; // only player 2 active\n\n        let commitments = calculate_commitment(cards, players, player_status);\n\n        // Only cards 4 and 5 (belonging to player 2) should have commitments\n        assert(commitments[0] == 0, \"Player 0 should be inactive\");\n        assert(commitments[1] == 0, \"Player 0 should be inactive\");\n        assert(commitments[2] == 0, \"Player 1 should be inactive\");\n        assert(commitments[3] == 0, \"Player 1 should be inactive\");\n        assert(commitments[4] != 0, \"Player 2 card 0 should have commitment\");\n        assert(commitments[5] != 0, \"Player 2 card 1 should have commitment\");\n        assert(commitments[6] == 0, \"Player 3 should be inactive\");\n        assert(commitments[7] == 0, \"Player 3 should be inactive\");\n        assert(commitments[8] == 0, \"Player 4 should be inactive\");\n        assert(commitments[9] == 0, \"Player 4 should be inactive\");\n    }\n\n    // -------------------------------------------------------------------------\n    // Reveal Circuit Integration Test\n    // -------------------------------------------------------------------------\n\n    #[test]\n    fn test_commitment_verification_workflow() {\n        // Simulates the reveal circuit verification workflow\n        let cards: [Field; 10] = [5, 15, 25, 35, 45, 10, 20, 30, 40, 50];\n        let players: [Field; 5] = [0xAAA, 0xBBB, 0xCCC, 0xDDD, 0xEEE];\n        let player_status: [bool; 5] = [true, true, true, true, true];\n\n        // Step 1: Calculate commitments (done during deal phase)\n        let onchain_commitments = calculate_commitment(cards, players, player_status);\n\n        // Step 2: Later, recalculate commitments (done during reveal phase)\n        let reveal_commitments = calculate_commitment(cards, players, player_status);\n\n        // Step 3: Verify they match (as the reveal circuit would do)\n        for i in 0..player_status.len() {\n            if player_status[i] {\n                assert(\n                    reveal_commitments[2 * i] == onchain_commitments[2 * i],\n                    \"Card commitment mismatch at showdown\",\n                );\n                assert(\n                    reveal_commitments[2 * i + 1] == onchain_commitments[2 * i + 1],\n                    \"Card commitment mismatch at showdown for player\",\n                );\n            }\n        }\n    }\n\n    // -------------------------------------------------------------------------\n    // Calculate Community Commitment Tests\n    // -------------------------------------------------------------------------\n\n    #[test]\n    fn test_calculate_community_commitment_is_deterministic() {\n        // Same inputs must produce the same commitment\n        let cards: [Field; 5] = [10, 20, 30, 40, 50];\n\n        let commitment1 = calculate_community_commitment(cards);\n        let commitment2 = calculate_community_commitment(cards);\n\n        assert(commitment1 == commitment2, \"Community commitment must be deterministic\");\n    }\n\n    #[test]\n    fn test_calculate_community_commitment_different_cards() {\n        // Different community cards should produce different commitments\n        let cards1: [Field; 5] = [1, 2, 3, 4, 5];\n        let cards2: [Field; 5] = [6, 7, 8, 9, 10];\n\n        let commitment1 = calculate_community_commitment(cards1);\n        let commitment2 = calculate_community_commitment(cards2);\n\n        assert(commitment1 != commitment2, \"Different cards should produce different commitments\");\n    }\n\n    #[test]\n    fn test_calculate_community_commitment_order_matters() {\n        // The order of cards affects the commitment (important for flop, turn, river)\n        let cards1: [Field; 5] = [1, 2, 3, 4, 5];\n        let cards2: [Field; 5] = [5, 4, 3, 2, 1]; // reversed order\n\n        let commitment1 = calculate_community_commitment(cards1);\n        let commitment2 = calculate_community_commitment(cards2);\n\n        assert(commitment1 != commitment2, \"Card order should affect commitment\");\n    }\n\n    #[test]\n    fn test_calculate_community_commitment_integration_with_dealing() {\n        // Full workflow: shuffle -> get cards -> extract community cards -> commit\n        let seed: Field = 0xc0ffee;\n        let deck = fisher_yates_shuffle(seed);\n        let dealt_cards = get_cards(deck);\n\n        // Community cards are the last 5 of the 15 dealt cards (indices 10-14)\n        let community_cards: [Field; 5] =\n            [dealt_cards[10], dealt_cards[11], dealt_cards[12], dealt_cards[13], dealt_cards[14]];\n\n        // Calculate commitment\n        let commitment1 = calculate_community_commitment(community_cards);\n\n        // Re-run the entire workflow for verification\n        let deck_verify = fisher_yates_shuffle(seed);\n        let dealt_verify = get_cards(deck_verify);\n        let community_verify: [Field; 5] = [\n            dealt_verify[10],\n            dealt_verify[11],\n            dealt_verify[12],\n            dealt_verify[13],\n            dealt_verify[14],\n        ];\n        let commitment2 = calculate_community_commitment(community_verify);\n\n        assert(commitment1 == commitment2, \"Community commitment should be reproducible from seed\");\n    }\n\n    #[test]\n    fn test_calculate_community_commitment_unique_for_different_deals() {\n        // Different shuffles should produce different community commitments\n        let deck1 = fisher_yates_shuffle(111);\n        let deck2 = fisher_yates_shuffle(222);\n\n        let cards1 = get_cards(deck1);\n        let cards2 = get_cards(deck2);\n\n        let community1: [Field; 5] = [cards1[10], cards1[11], cards1[12], cards1[13], cards1[14]];\n        let community2: [Field; 5] = [cards2[10], cards2[11], cards2[12], cards2[13], cards2[14]];\n\n        let commitment1 = calculate_community_commitment(community1);\n        let commitment2 = calculate_community_commitment(community2);\n\n        assert(\n            commitment1 != commitment2,\n            \"Different shuffles should produce different community commitments\",\n        );\n    }\n}\n","path":"/home/ally/DevEnv/pvtDock/KH/poker-solana/backend/src/services/circuitry/assist/src/lib.nr"},"59":{"source":"use std::default::Default;\nuse std::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        self.state[0] += self.cache[0];\n        self.state[1] += self.cache[1];\n        self.state[2] += self.cache[2];\n        self.state = crate::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut state = [0; 4];\n        state[RATE] = iv;\n\n        if std::runtime::is_unconstrained() {\n            for i in 0..(in_len / RATE) {\n                state[0] += input[i * RATE];\n                state[1] += input[i * RATE + 1];\n                state[2] += input[i * RATE + 2];\n                state = crate::poseidon2_permutation(state, 4);\n            }\n\n            // handle remaining elements after last full RATE-sized chunk\n            let remainder_start = (in_len / RATE) * RATE;\n            for j in remainder_start..in_len {\n                state[j - remainder_start] += input[j];\n            }\n        } else {\n            let mut states: [[Field; 4]; N / RATE + 1] = [[0; 4]; N / RATE + 1];\n            states[0] = state;\n\n            // process all full RATE-sized chunks, storing state after each permutation\n            for chunk_idx in 0..(N / RATE) {\n                for i in 0..RATE {\n                    state[i] += input[chunk_idx * RATE + i];\n                }\n                state = crate::poseidon2_permutation(state, 4);\n                states[chunk_idx + 1] = state;\n            }\n\n            // get state at the last full block before in_len\n            let first_partially_filled_chunk = in_len / RATE;\n            state = states[first_partially_filled_chunk];\n\n            // handle remaining elements after last full RATE-sized chunk\n            let remainder_start = (in_len / RATE) * RATE;\n            for j in 0..RATE {\n                let idx = remainder_start + j;\n                if idx < in_len {\n                    state[j] += input[idx];\n                }\n            }\n        }\n\n        // always run final permutation unless we just completed a full chunk\n        // still need to permute once if in_len is 0\n        if (in_len == 0) | (in_len % RATE != 0) {\n            state = crate::poseidon2_permutation(state, 4)\n        };\n\n        state[0]\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n","path":"/home/ally/nargo/github.com/noir-lang/poseidon/v0.2.2/src/poseidon2.nr"}}};

export async function calculate_community_commitment(cards: Field[], foreignCallHandler?: ForeignCallHandler): Promise<Field> {
  const program = new Noir(calculate_community_commitment_circuit);
  const args: InputMap = { cards };
  const { returnValue } = await program.execute(args, foreignCallHandler);
  return returnValue as Field;
}
export type fisher_yates_shuffleInputType = {
  seed: Field;
}

export type fisher_yates_shuffleReturnType = Field[];
export const fisher_yates_shuffle_circuit: CompiledCircuit = {"abi":{"parameters":[{"name":"seed","type":{"kind":"field"},"visibility":"private"}],"return_type":{"abi_type":{"kind":"array","length":52,"type":{"kind":"field"}},"visibility":"private"},"error_types":{"361444214588792908":{"error_kind":"string","string":"attempt to multiply with overflow"},"12469291177396340830":{"error_kind":"string","string":"call to assert_max_bit_size"},"14990209321349310352":{"error_kind":"string","string":"attempt to add with overflow"},"15764276373176857197":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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","debug_symbols":"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","file_map":{"17":{"source":"use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\npub(crate) global PLO: Field = 53438638232309528389504892708671455233;\npub(crate) global PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 128 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low = (x as u128) as Field;\n    let high = (x - low) / TWO_POW_128;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    // Safety: borrow is enforced to be boolean due to its type.\n    // if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n    // if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        // Safety: decomposition is properly checked below\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            // Safety: already unconstrained\n            unsafe { field_less_than(b, a) },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unsafe in unconstrained\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        // Safety: Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n\n    #[test]\n    fn check_decompose_edge_cases() {\n        assert_eq(decompose(0), (0, 0));\n        assert_eq(decompose(TWO_POW_128 - 1), (TWO_POW_128 - 1, 0));\n        assert_eq(decompose(TWO_POW_128 + 1), (1, 1));\n        assert_eq(decompose(TWO_POW_128 * 2), (0, 2));\n        assert_eq(decompose(TWO_POW_128 * 2 + 0x1234567890), (0x1234567890, 2));\n    }\n\n    #[test]\n    fn check_decompose_large_values() {\n        let large_field = 0xffffffffffffffff;\n        let (lo, hi) = decompose(large_field);\n        assert_eq(large_field, lo + TWO_POW_128 * hi);\n\n        let large_value = large_field - TWO_POW_128;\n        let (lo2, hi2) = decompose(large_value);\n        assert_eq(large_value, lo2 + TWO_POW_128 * hi2);\n    }\n\n    #[test]\n    fn check_lt_comprehensive() {\n        assert(lt(0, 1));\n        assert(!lt(1, 0));\n        assert(!lt(0, 0));\n        assert(!lt(42, 42));\n\n        assert(lt(TWO_POW_128 - 1, TWO_POW_128));\n        assert(!lt(TWO_POW_128, TWO_POW_128 - 1));\n    }\n}\n","path":"std/field/bn254.nr"},"18":{"source":"pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        __assert_max_bit_size(self, BIT_SIZE);\n    }\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting array will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = __to_le_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting array will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = __to_be_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_le_radix(self, radix)\n    }\n\n    fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_be_radix(self, radix)\n    }\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(apply_range_constraint)]\nfn __assert_max_bit_size(value: Field, bit_size: u32) {}\n\n// `_radix` must be less than 256\n#[builtin(to_le_radix)]\nfn __to_le_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n// `_radix` must be less than 256\n#[builtin(to_be_radix)]\nfn __to_be_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n/// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n/// This array will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting array will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_le_bits)]\nfn __to_le_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n/// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n/// This array will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting array will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_be_bits)]\nfn __to_be_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime, static_assert};\n    use super::{\n        field_less_than, modulus_be_bits, modulus_be_bytes, modulus_le_bits, modulus_le_bytes,\n    };\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(\"radix must be greater than 1\");\n        }\n    }\n\n    // Updated test to account for Brillig restriction that radix must be greater than 2\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_brillig_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 1;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(\"radix must be greater than 1\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(\"radix must be less than or equal to 256\")\n        }\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 16 limbs\")]\n    unconstrained fn not_enough_limbs_brillig() {\n        let _: [u8; 16] = 0x100000000000000000000000000000000.to_le_bytes();\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 16 limbs\")]\n    fn not_enough_limbs() {\n        let _: [u8; 16] = 0x100000000000000000000000000000000.to_le_bytes();\n    }\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n\n    #[test]\n    unconstrained fn test_large_field_values_unconstrained() {\n        let large_field = 0xffffffffffffffff;\n\n        let bits: [u1; 64] = large_field.to_le_bits();\n        assert_eq(bits[0], 1);\n\n        let bytes: [u8; 8] = large_field.to_le_bytes();\n        assert_eq(Field::from_le_bytes::<8>(bytes), large_field);\n\n        let radix_bytes: [u8; 8] = large_field.to_le_radix(256);\n        assert_eq(Field::from_le_bytes::<8>(radix_bytes), large_field);\n    }\n\n    #[test]\n    fn test_large_field_values() {\n        let large_val = 0xffffffffffffffff;\n\n        let bits: [u1; 64] = large_val.to_le_bits();\n        assert_eq(bits[0], 1);\n\n        let bytes: [u8; 8] = large_val.to_le_bytes();\n        assert_eq(Field::from_le_bytes::<8>(bytes), large_val);\n\n        let radix_bytes: [u8; 8] = large_val.to_le_radix(256);\n        assert_eq(Field::from_le_bytes::<8>(radix_bytes), large_val);\n    }\n\n    #[test]\n    fn test_decomposition_edge_cases() {\n        let zero_bits: [u1; 8] = 0.to_le_bits();\n        assert_eq(zero_bits, [0; 8]);\n\n        let zero_bytes: [u8; 8] = 0.to_le_bytes();\n        assert_eq(zero_bytes, [0; 8]);\n\n        let one_bits: [u1; 8] = 1.to_le_bits();\n        let expected: [u1; 8] = [1, 0, 0, 0, 0, 0, 0, 0];\n        assert_eq(one_bits, expected);\n\n        let pow2_bits: [u1; 8] = 4.to_le_bits();\n        let expected: [u1; 8] = [0, 0, 1, 0, 0, 0, 0, 0];\n        assert_eq(pow2_bits, expected);\n    }\n\n    #[test]\n    fn test_pow_32() {\n        assert_eq(2.pow_32(3), 8);\n        assert_eq(3.pow_32(2), 9);\n        assert_eq(5.pow_32(0), 1);\n        assert_eq(7.pow_32(1), 7);\n\n        assert_eq(2.pow_32(10), 1024);\n\n        assert_eq(0.pow_32(5), 0);\n        assert_eq(0.pow_32(0), 1);\n\n        assert_eq(1.pow_32(100), 1);\n    }\n\n    #[test]\n    fn test_sgn0() {\n        assert_eq(0.sgn0(), 0);\n        assert_eq(2.sgn0(), 0);\n        assert_eq(4.sgn0(), 0);\n        assert_eq(100.sgn0(), 0);\n\n        assert_eq(1.sgn0(), 1);\n        assert_eq(3.sgn0(), 1);\n        assert_eq(5.sgn0(), 1);\n        assert_eq(101.sgn0(), 1);\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 8 limbs\")]\n    fn test_bit_decomposition_overflow() {\n        // 8 bits can't represent large field values\n        let large_val = 0x1000000000000000;\n        let _: [u1; 8] = large_val.to_le_bits();\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 4 limbs\")]\n    fn test_byte_decomposition_overflow() {\n        // 4 bytes can't represent large field values\n        let large_val = 0x1000000000000000;\n        let _: [u8; 4] = large_val.to_le_bytes();\n    }\n\n    #[test]\n    fn test_to_from_be_bytes_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this byte produces the expected 32 BE bytes for (modulus - 1)\n            let mut p_minus_1_bytes: [u8; 32] = modulus_be_bytes().as_array();\n            assert(p_minus_1_bytes[32 - 1] > 0);\n            p_minus_1_bytes[32 - 1] -= 1;\n\n            let p_minus_1 = Field::from_be_bytes::<32>(p_minus_1_bytes);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 32 BE bytes produces the same bytes\n            let p_minus_1_converted_bytes: [u8; 32] = p_minus_1.to_be_bytes();\n            assert_eq(p_minus_1_converted_bytes, p_minus_1_bytes);\n\n            // checking that incrementing this byte produces 32 BE bytes for (modulus + 1)\n            let mut p_plus_1_bytes: [u8; 32] = modulus_be_bytes().as_array();\n            assert(p_plus_1_bytes[32 - 1] < 255);\n            p_plus_1_bytes[32 - 1] += 1;\n\n            let p_plus_1 = Field::from_be_bytes::<32>(p_plus_1_bytes);\n            assert_eq(p_plus_1, 1);\n\n            // checking that converting p_plus_1 to 32 BE bytes produces the same\n            // byte set to 1 as p_plus_1_bytes and otherwise zeroes\n            let mut p_plus_1_converted_bytes: [u8; 32] = p_plus_1.to_be_bytes();\n            assert_eq(p_plus_1_converted_bytes[32 - 1], 1);\n            p_plus_1_converted_bytes[32 - 1] = 0;\n            assert_eq(p_plus_1_converted_bytes, [0; 32]);\n\n            // checking that Field::from_be_bytes::<32> on the Field modulus produces 0\n            assert_eq(modulus_be_bytes().len(), 32);\n            let p = Field::from_be_bytes::<32>(modulus_be_bytes().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 32 BE bytes produces 32 zeroes\n            let p_bytes: [u8; 32] = 0.to_be_bytes();\n            assert_eq(p_bytes, [0; 32]);\n        }\n    }\n\n    #[test]\n    fn test_to_from_le_bytes_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this byte produces the expected 32 LE bytes for (modulus - 1)\n            let mut p_minus_1_bytes: [u8; 32] = modulus_le_bytes().as_array();\n            assert(p_minus_1_bytes[0] > 0);\n            p_minus_1_bytes[0] -= 1;\n\n            let p_minus_1 = Field::from_le_bytes::<32>(p_minus_1_bytes);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 32 BE bytes produces the same bytes\n            let p_minus_1_converted_bytes: [u8; 32] = p_minus_1.to_le_bytes();\n            assert_eq(p_minus_1_converted_bytes, p_minus_1_bytes);\n\n            // checking that incrementing this byte produces 32 LE bytes for (modulus + 1)\n            let mut p_plus_1_bytes: [u8; 32] = modulus_le_bytes().as_array();\n            assert(p_plus_1_bytes[0] < 255);\n            p_plus_1_bytes[0] += 1;\n\n            let p_plus_1 = Field::from_le_bytes::<32>(p_plus_1_bytes);\n            assert_eq(p_plus_1, 1);\n\n            // checking that converting p_plus_1 to 32 LE bytes produces the same\n            // byte set to 1 as p_plus_1_bytes and otherwise zeroes\n            let mut p_plus_1_converted_bytes: [u8; 32] = p_plus_1.to_le_bytes();\n            assert_eq(p_plus_1_converted_bytes[0], 1);\n            p_plus_1_converted_bytes[0] = 0;\n            assert_eq(p_plus_1_converted_bytes, [0; 32]);\n\n            // checking that Field::from_le_bytes::<32> on the Field modulus produces 0\n            assert_eq(modulus_le_bytes().len(), 32);\n            let p = Field::from_le_bytes::<32>(modulus_le_bytes().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 32 LE bytes produces 32 zeroes\n            let p_bytes: [u8; 32] = 0.to_le_bytes();\n            assert_eq(p_bytes, [0; 32]);\n        }\n    }\n\n    /// Convert a little endian bit array to a field element.\n    /// If the provided bit array overflows the field modulus then the Field will silently wrap around.\n    fn from_le_bits<let N: u32>(bits: [u1; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bits().len(),\n            \"N must be less than or equal to modulus_le_bits().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bits[i] as Field) * v;\n            v = v * 2;\n        }\n        result\n    }\n\n    /// Convert a big endian bit array to a field element.\n    /// If the provided bit array overflows the field modulus then the Field will silently wrap around.\n    fn from_be_bits<let N: u32>(bits: [u1; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bits[N - 1 - i] as Field) * v;\n            v = v * 2;\n        }\n        result\n    }\n\n    #[test]\n    fn test_to_from_be_bits_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this bit produces the expected 254 BE bits for (modulus - 1)\n            let mut p_minus_1_bits: [u1; 254] = modulus_be_bits().as_array();\n            assert(p_minus_1_bits[254 - 1] > 0);\n            p_minus_1_bits[254 - 1] -= 1;\n\n            let p_minus_1 = from_be_bits::<254>(p_minus_1_bits);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 254 BE bits produces the same bits\n            let p_minus_1_converted_bits: [u1; 254] = p_minus_1.to_be_bits();\n            assert_eq(p_minus_1_converted_bits, p_minus_1_bits);\n\n            // checking that incrementing this bit produces 254 BE bits for (modulus + 4)\n            let mut p_plus_4_bits: [u1; 254] = modulus_be_bits().as_array();\n            assert(p_plus_4_bits[254 - 3] < 1);\n            p_plus_4_bits[254 - 3] += 1;\n\n            let p_plus_4 = from_be_bits::<254>(p_plus_4_bits);\n            assert_eq(p_plus_4, 4);\n\n            // checking that converting p_plus_4 to 254 BE bits produces the same\n            // bit set to 1 as p_plus_4_bits and otherwise zeroes\n            let mut p_plus_4_converted_bits: [u1; 254] = p_plus_4.to_be_bits();\n            assert_eq(p_plus_4_converted_bits[254 - 3], 1);\n            p_plus_4_converted_bits[254 - 3] = 0;\n            assert_eq(p_plus_4_converted_bits, [0; 254]);\n\n            // checking that Field::from_be_bits::<254> on the Field modulus produces 0\n            assert_eq(modulus_be_bits().len(), 254);\n            let p = from_be_bits::<254>(modulus_be_bits().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 254 BE bytes produces 254 zeroes\n            let p_bits: [u1; 254] = 0.to_be_bits();\n            assert_eq(p_bits, [0; 254]);\n        }\n    }\n\n    #[test]\n    fn test_to_from_le_bits_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this bit produces the expected 254 LE bits for (modulus - 1)\n            let mut p_minus_1_bits: [u1; 254] = modulus_le_bits().as_array();\n            assert(p_minus_1_bits[0] > 0);\n            p_minus_1_bits[0] -= 1;\n\n            let p_minus_1 = from_le_bits::<254>(p_minus_1_bits);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 254 BE bits produces the same bits\n            let p_minus_1_converted_bits: [u1; 254] = p_minus_1.to_le_bits();\n            assert_eq(p_minus_1_converted_bits, p_minus_1_bits);\n\n            // checking that incrementing this bit produces 254 LE bits for (modulus + 4)\n            let mut p_plus_4_bits: [u1; 254] = modulus_le_bits().as_array();\n            assert(p_plus_4_bits[2] < 1);\n            p_plus_4_bits[2] += 1;\n\n            let p_plus_4 = from_le_bits::<254>(p_plus_4_bits);\n            assert_eq(p_plus_4, 4);\n\n            // checking that converting p_plus_4 to 254 LE bits produces the same\n            // bit set to 1 as p_plus_4_bits and otherwise zeroes\n            let mut p_plus_4_converted_bits: [u1; 254] = p_plus_4.to_le_bits();\n            assert_eq(p_plus_4_converted_bits[2], 1);\n            p_plus_4_converted_bits[2] = 0;\n            assert_eq(p_plus_4_converted_bits, [0; 254]);\n\n            // checking that Field::from_le_bits::<254> on the Field modulus produces 0\n            assert_eq(modulus_le_bits().len(), 254);\n            let p = from_le_bits::<254>(modulus_le_bits().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 254 LE bytes produces 254 zeroes\n            let p_bits: [u1; 254] = 0.to_le_bits();\n            assert_eq(p_bits, [0; 254]);\n        }\n    }\n}\n","path":"std/field/mod.nr"},"19":{"source":"// Exposed only for usage in `std::meta`\npub(crate) mod poseidon2;\n\nuse crate::default::Default;\nuse crate::embedded_curve_ops::{\n    EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_array_return,\n};\nuse crate::meta::derive_via;\n\n#[foreign(sha256_compression)]\n// docs:start:sha256_compression\npub fn sha256_compression(input: [u32; 16], state: [u32; 8]) -> [u32; 8] {}\n// docs:end:sha256_compression\n\n#[foreign(keccakf1600)]\n// docs:start:keccakf1600\npub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {}\n// docs:end:keccakf1600\n\npub mod keccak {\n    #[deprecated(\"This function has been moved to std::hash::keccakf1600\")]\n    pub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {\n        super::keccakf1600(input)\n    }\n}\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{\n    if crate::runtime::is_unconstrained() {\n        // Temporary measure while Barretenberg is main proving system.\n        // Please open an issue if you're working on another proving system and running into problems due to this.\n        crate::static_assert(\n            N <= 1024,\n            \"Barretenberg cannot prove blake3 hashes with inputs larger than 1024 bytes\",\n        );\n    }\n    __blake3(input)\n}\n\n#[foreign(blake3)]\nfn __blake3<let N: u32>(input: [u8; N]) -> [u8; 32] {}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\n#[inline_always]\npub fn pedersen_commitment_with_separator<let N: u32>(\n    input: [Field; N],\n    separator: u32,\n) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        // we use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        points[i] = from_field_unsafe(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    multi_scalar_mul(generators, points)\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[no_predicates]\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let mut scalars: [EmbeddedCurveScalar; N + 1] = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N + 1];\n    let mut generators: [EmbeddedCurvePoint; N + 1] =\n        [EmbeddedCurvePoint::point_at_infinity(); N + 1];\n    let domain_generators: [EmbeddedCurvePoint; N] =\n        derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n\n    for i in 0..N {\n        scalars[i] = from_field_unsafe(input[i]);\n        generators[i] = domain_generators[i];\n    }\n    scalars[N] = EmbeddedCurveScalar { lo: N as Field, hi: 0 as Field };\n\n    let length_generator: [EmbeddedCurvePoint; 1] =\n        derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    generators[N] = length_generator[0];\n    multi_scalar_mul_array_return(generators, scalars, true)[0].x\n}\n\n#[field(bn254)]\n#[inline_always]\npub fn derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    // TODO(https://github.com/noir-lang/noir/issues/5672): Add back assert_constant on starting_index\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {}\n\n#[field(bn254)]\n// Decompose the input 'bn254 scalar' into two 128 bits limbs.\n// It is called 'unsafe' because it does not assert the limbs are 128 bits\n// Assuming the limbs are 128 bits:\n// Assert the decomposition does not overflow the field size.\nfn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {\n    // Safety: xlo and xhi decomposition is checked below\n    let (xlo, xhi) = unsafe { crate::field::bn254::decompose_hint(scalar) };\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);\n    // Check that the decomposition does not overflow the field size\n    let (a, b) = if xhi == crate::field::bn254::PHI {\n        (xlo, crate::field::bn254::PLO)\n    } else {\n        (xhi, crate::field::bn254::PHI)\n    };\n    crate::field::bn254::assert_lt(a, b);\n\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n\npub fn poseidon2_permutation<let N: u32>(input: [Field; N], state_len: u32) -> [Field; N] {\n    assert_eq(input.len(), state_len);\n    poseidon2_permutation_internal(input)\n}\n\n#[foreign(poseidon2_permutation)]\nfn poseidon2_permutation_internal<let N: u32>(input: [Field; N]) -> [Field; N] {}\n\n// Generic hashing support.\n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\n#[derive_via(derive_hash)]\npub trait Hash {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher;\n}\n\n// docs:start:derive_hash\ncomptime fn derive_hash(s: TypeDefinition) -> Quoted {\n    let name = quote { $crate::hash::Hash };\n    let signature = quote { fn hash<H>(_self: Self, _state: &mut H) where H: $crate::hash::Hasher };\n    let for_each_field = |name| quote { _self.$name.hash(_state); };\n    crate::meta::make_trait_impl(\n        s,\n        name,\n        signature,\n        for_each_field,\n        quote {},\n        |fields| fields,\n    )\n}\n// docs:end:derive_hash\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\npub trait Hasher {\n    fn finish(self) -> Field;\n\n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\npub trait BuildHasher {\n    type H: Hasher;\n\n    fn build_hasher(self) -> H;\n}\n\npub struct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    type H = H;\n\n    fn build_hasher(_self: Self) -> H {\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn default() -> Self {\n        BuildHasherDefault {}\n    }\n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u1 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u128 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u8 as Field);\n    }\n}\n\nimpl Hash for i16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u16 as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u32 as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u64 as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H)\n    where\n        H: Hasher,\n    {}\n}\n\nimpl<T, let N: u32> Hash for [T; N]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B)\nwhere\n    A: Hash,\n    B: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n    E: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n// Some test vectors for Pedersen hash and Pedersen Commitment.\n// They have been generated using the same functions so the tests are for now useless\n// but they will be useful when we switch to Noir implementation.\n#[test]\nfn assert_pedersen() {\n    assert_eq(\n        pedersen_hash_with_separator([1], 1),\n        0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1], 1),\n        EmbeddedCurvePoint {\n            x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,\n            y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,\n            is_infinite: false,\n        },\n    );\n\n    assert_eq(\n        pedersen_hash_with_separator([1, 2], 2),\n        0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2], 2),\n        EmbeddedCurvePoint {\n            x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,\n            y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3], 3),\n        0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3], 3),\n        EmbeddedCurvePoint {\n            x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,\n            y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4], 4),\n        0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4], 4),\n        EmbeddedCurvePoint {\n            x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,\n            y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5),\n        0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5),\n        EmbeddedCurvePoint {\n            x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,\n            y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6),\n        0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6),\n        EmbeddedCurvePoint {\n            x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,\n            y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        EmbeddedCurvePoint {\n            x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,\n            y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        EmbeddedCurvePoint {\n            x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,\n            y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        EmbeddedCurvePoint {\n            x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,\n            y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        EmbeddedCurvePoint {\n            x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,\n            y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,\n            is_infinite: false,\n        },\n    );\n}\n","path":"std/hash/mod.nr"},"51":{"source":"use poseidon::poseidon2::Poseidon2;\nuse std::field::bn254::assert_lt;\n\n/// Number of cards in a standard deck.\npub global DECK_SIZE: u32 = 52;\n\n/// Number of cards to deal for gameplay (5 players * 2 cards + 5 community cards = 15).\npub global CARDS_TO_DEAL: u32 = 15;\n\n// Domain separators prevent cross-protocol hash collisions.\npub global HASH_DOMAIN_SEPARATOR_SEED: Field = 1;\npub global HASH_DOMAIN_SEPARATOR_DECK: Field = 2;\npub global HASH_DOMAIN_SEPARATOR_CARD: Field = 3;\n\n/// Domain separator for Fisher-Yates RNG state transitions.\npub global HASH_DOMAIN_SEPARATOR_RNG: Field = 4;\npub global PADDING_NONCE: Field = 5;\n\n/// Performs a deterministic Fisher-Yates shuffle on a 52-card deck.\n///\n/// # Arguments\n/// * `seed` - Random seed from on-chain randomness source.\n///\n/// # Returns\n/// A shuffled deck represented as an array of Field elements (0-51).\n///\n/// # Security Properties\n/// - Deterministic: Same seed always produces the same shuffle.\n/// - Uniform: Each permutation is equally likely given a uniformly random seed.\n/// - Verifiable: The shuffle can be independently verified with the seed.\n#[export]\npub fn fisher_yates_shuffle(seed: Field) -> [Field; DECK_SIZE] {\n    // Initialize the deck as 0-51 indices\n    let mut deck = [0; DECK_SIZE];\n    for i in 0..DECK_SIZE {\n        deck[i] = i as Field;\n    }\n\n    // Initialize the RNG state with the random seed using domain separator\n    let mut rng_state = Poseidon2::hash([HASH_DOMAIN_SEPARATOR_RNG, seed], 2);\n\n    // Perform the Fisher-Yates shuffle\n    // Iterate from the last element down to the second element\n    for i in 0..(DECK_SIZE - 1) {\n        let idx = (DECK_SIZE - 1) - i;\n\n        // Generate random hash with domain-separated RNG state update\n        rng_state = Poseidon2::hash([HASH_DOMAIN_SEPARATOR_RNG, rng_state, idx as Field], 3);\n\n        // Calculate the swap index unconstrained\n        let range = (idx + 1) as Field;\n        // Safety: constraints enabled by proceeding assertions\n        let (quotient, remainder) = unsafe { divide_hint(rng_state, range) };\n\n        // Constrain the division result: rng_state = quotient * range + remainder\n        assert(rng_state == quotient * range + remainder);\n        // Ensure remainder is in valid range [0, range)\n        assert_lt(remainder, range);\n\n        let swap_idx = remainder as u32;\n\n        // Perform the swap\n        if swap_idx != idx {\n            let temp = deck[idx];\n            deck[idx] = deck[swap_idx];\n            deck[swap_idx] = temp;\n        }\n    }\n\n    deck\n}\n\n/// Unconstrained hint for field division.\n/// Computes (quotient, remainder) such that numerator = quotient * denominator + remainder.\nunconstrained fn divide_hint(numerator: Field, denominator: Field) -> (Field, Field) {\n    // NOTE: assuming denominator is small enough to fit in u32 (as is the case for a DECK_SIZE of 52)\n    let den_u64 = denominator as u64;\n    // Minimal check to avoid division by zero\n    assert(den_u64 != 0);\n    // Ensure denominator fits in u32 to guarantee 'remainder * 256' fits in u64\n    assert(den_u64 <= 4294967295);\n\n    let bytes: [u8; 32] = numerator.to_be_bytes();\n    let mut remainder: u64 = 0;\n    let mut quotient: Field = 0;\n\n    for i in 0..32 {\n        let b = bytes[i] as u64;\n        let val = remainder * 256 + b;\n        let q_digit = val / den_u64;\n        let r_digit = val % den_u64;\n\n        quotient = quotient * 256 + (q_digit as Field);\n        remainder = r_digit;\n    }\n    (quotient, remainder as Field)\n}\n\n/// Computes the Merkle root of a shuffled deck.\n///\n/// # Arguments\n/// * `deck` - The shuffled deck array.\n/// * `seed` - The shuffle seed (used to derive salt for binding).\n///\n/// # Returns\n/// The Merkle root hash of the deck.\n///\n/// # Implementation Notes\n/// - Uses a 64-leaf tree (52 cards + 12 padding leaves).\n/// - Each card is hashed with its position and a seed-derived salt.\n#[export]\npub fn merkle_root(deck: [Field; DECK_SIZE], seed: Field) -> Field {\n    // Generate salt for binding cards to this specific shuffle\n    let salt = derive_salt(seed);\n\n    // Hash all cards directly into buffer\n    let mut buffer: [Field; 64] = [0; 64];\n\n    for i in 0..DECK_SIZE {\n        buffer[i] = hash_card_in_deck(deck[i], i as Field, salt);\n    }\n\n    // Pad buffer with a fixed value to reach power of 2 tree size\n    let padding = Poseidon2::hash([HASH_DOMAIN_SEPARATOR_DECK, PADDING_NONCE], 2);\n    for i in DECK_SIZE..64 {\n        buffer[i] = padding;\n    }\n\n    // Build tree bottom-up, reusing buffer space\n    // After each level, results are stored in the first half of the buffer\n    let mut size = 64;\n    for _ in 0..6 {\n        let next_size = size / 2;\n        for i in 0..next_size {\n            buffer[i] = merkle_a_pair(buffer[i * 2], buffer[i * 2 + 1]);\n        }\n        size = next_size;\n    }\n\n    buffer[0]\n}\n\n/// Derives a salt from the shuffle seed for card hashing.\npub fn derive_salt(seed: Field) -> Field {\n    Poseidon2::hash([seed, HASH_DOMAIN_SEPARATOR_CARD], 2)\n}\n\n/// Hashes a card at a specific position with salt.\n/// The position ensures uniqueness even for duplicate card values.\npub fn hash_card_in_deck(card: Field, position: Field, salt: Field) -> Field {\n    Poseidon2::hash([HASH_DOMAIN_SEPARATOR_CARD, card, position, salt], 4)\n}\n\n/// Hashes two child nodes to produce a parent node in the Merkle tree.\npub fn merkle_a_pair(left: Field, right: Field) -> Field {\n    Poseidon2::hash([left, right], 2)\n}\n\n/// Extracts the first CARDS_TO_DEAL cards from the shuffled deck.\n///\n/// # Arguments\n/// * `deck` - The shuffled deck array.\n///\n/// # Returns\n/// An array of the first 15 cards for gameplay.\n#[export]\npub fn get_cards(deck: [Field; DECK_SIZE]) -> [Field; CARDS_TO_DEAL] {\n    let mut cards = [0; CARDS_TO_DEAL];\n    for i in 0..CARDS_TO_DEAL {\n        cards[i] = deck[i];\n    }\n    cards\n}\n\n/// Commitments of card allocations to respective players\n///\n/// # Arguments\n/// * `cards` - The cards array.\n/// * `players` - The players array.\n/// * `player_status` - The player status array - if player is not in the game, commitment is 0\n///\n/// # Returns\n/// An array of commitments for the cards.\n#[export]\npub fn calculate_commitment(\n    cards: [Field; 10],\n    players: [Field; 5],\n    player_status: [bool; 5],\n) -> [Field; 10] {\n    let mut commitments: [Field; 10] = [0; 10];\n    let mut k = 0;\n\n    for i in 0..cards.len() {\n        let player: Field = players[k];\n\n        commitments[i] = if player_status[k] {\n            Poseidon2::hash([cards[i], player], 2)\n        } else {\n            0\n        };\n\n        if (i % 2 != 0) {\n            k += 1;\n        }\n    }\n\n    commitments\n}\n\n/// Commitment of community cards\n///\n/// # Arguments\n/// * `cards` - The cards array.\n///\n/// # Returns\n/// The commitment for the community cards.\n#[export]\npub fn calculate_community_commitment(cards: [Field; 5]) -> Field {\n    Poseidon2::hash([cards[0], cards[1], cards[2], cards[3], cards[4]], 5)\n}\n\n// =============================================================================\n// Test Module\n// =============================================================================\n\nmod tests {\n    use super::{\n        calculate_commitment, calculate_community_commitment, CARDS_TO_DEAL, DECK_SIZE, derive_salt,\n        fisher_yates_shuffle, get_cards, hash_card_in_deck, merkle_a_pair, merkle_root,\n    };\n    use poseidon::poseidon2::Poseidon2;\n\n    // -------------------------------------------------------------------------\n    // Fisher-Yates Shuffle Tests\n    // -------------------------------------------------------------------------\n\n    #[test]\n    fn test_shuffle_produces_valid_permutation() {\n        // A valid permutation contains each card exactly once\n        let seed: Field = 12345;\n        let deck = fisher_yates_shuffle(seed);\n\n        // Check that all cards 0-51 appear exactly once\n        let mut card_count: [u32; DECK_SIZE] = [0; DECK_SIZE];\n        for i in 0..DECK_SIZE {\n            let card_idx = deck[i] as u32;\n            assert(card_idx < DECK_SIZE, \"Card index out of bounds\");\n            card_count[card_idx] += 1;\n        }\n\n        for i in 0..DECK_SIZE {\n            assert(card_count[i] == 1, \"Each card must appear exactly once\");\n        }\n    }\n\n    #[test]\n    fn test_shuffle_is_deterministic() {\n        // Same seed must produce the same shuffle\n        let seed: Field = 0xabcdef123456;\n        let deck1 = fisher_yates_shuffle(seed);\n        let deck2 = fisher_yates_shuffle(seed);\n\n        for i in 0..DECK_SIZE {\n            assert(deck1[i] == deck2[i], \"Shuffle must be deterministic\");\n        }\n    }\n\n    #[test]\n    fn test_shuffle_different_seeds_produce_different_decks() {\n        let deck1 = fisher_yates_shuffle(1);\n        let deck2 = fisher_yates_shuffle(2);\n\n        // At least one card should be in a different position\n        let mut has_difference = false;\n        for i in 0..DECK_SIZE {\n            if deck1[i] != deck2[i] {\n                has_difference = true;\n            }\n        }\n        assert(has_difference, \"Different seeds should produce different shuffles\");\n    }\n\n    #[test]\n    fn test_shuffle_with_zero_seed() {\n        // Zero seed should still produce a valid permutation\n        let deck = fisher_yates_shuffle(0);\n\n        let mut card_count: [u32; DECK_SIZE] = [0; DECK_SIZE];\n        for i in 0..DECK_SIZE {\n            let card_idx = deck[i] as u32;\n            card_count[card_idx] += 1;\n        }\n\n        for i in 0..DECK_SIZE {\n            assert(card_count[i] == 1, \"Each card must appear exactly once\");\n        }\n    }\n\n    // -------------------------------------------------------------------------\n    // Merkle Root Tests\n    // -------------------------------------------------------------------------\n\n    #[test]\n    fn test_merkle_root_is_deterministic() {\n        let seed: Field = 42;\n        let deck = fisher_yates_shuffle(seed);\n\n        let root1 = merkle_root(deck, seed);\n        let root2 = merkle_root(deck, seed);\n\n        assert(root1 == root2, \"Merkle root must be deterministic\");\n    }\n\n    #[test]\n    fn test_merkle_root_different_decks_produce_different_roots() {\n        let deck1 = fisher_yates_shuffle(100);\n        let deck2 = fisher_yates_shuffle(200);\n\n        let root1 = merkle_root(deck1, 100);\n        let root2 = merkle_root(deck2, 200);\n\n        assert(root1 != root2, \"Different decks should produce different roots\");\n    }\n\n    #[test]\n    fn test_merkle_root_same_deck_different_seed_produces_different_root() {\n        // The seed affects the salt, so same deck with different seeds = different roots\n        let deck = fisher_yates_shuffle(123);\n\n        let root1 = merkle_root(deck, 123);\n        let root2 = merkle_root(deck, 456);\n\n        assert(root1 != root2, \"Same deck with different seeds should produce different roots\");\n    }\n\n    // -------------------------------------------------------------------------\n    // Helper Function Tests\n    // -------------------------------------------------------------------------\n\n    #[test]\n    fn test_derive_salt_is_deterministic() {\n        let seed: Field = 999;\n        let salt1 = derive_salt(seed);\n        let salt2 = derive_salt(seed);\n\n        assert(salt1 == salt2, \"derive_salt must be deterministic\");\n    }\n\n    #[test]\n    fn test_derive_salt_different_seeds_produce_different_salts() {\n        let salt1 = derive_salt(1);\n        let salt2 = derive_salt(2);\n\n        assert(salt1 != salt2, \"Different seeds should produce different salts\");\n    }\n\n    #[test]\n    fn test_hash_card_is_deterministic() {\n        let card: Field = 10;\n        let position: Field = 5;\n        let salt: Field = 12345;\n\n        let hash1 = hash_card_in_deck(card, position, salt);\n        let hash2 = hash_card_in_deck(card, position, salt);\n\n        assert(hash1 == hash2, \"hash_card_in_deck must be deterministic\");\n    }\n\n    #[test]\n    fn test_hash_card_position_affects_hash() {\n        let card: Field = 10;\n        let salt: Field = 12345;\n\n        let hash1 = hash_card_in_deck(card, 0, salt);\n        let hash2 = hash_card_in_deck(card, 1, salt);\n\n        assert(hash1 != hash2, \"Different positions should produce different hashes\");\n    }\n\n    #[test]\n    fn test_merkle_pair_is_deterministic() {\n        let left: Field = 111;\n        let right: Field = 222;\n\n        let hash1 = merkle_a_pair(left, right);\n        let hash2 = merkle_a_pair(left, right);\n\n        assert(hash1 == hash2, \"merkle_a_pair must be deterministic\");\n    }\n\n    #[test]\n    fn test_merkle_pair_order_matters() {\n        let a: Field = 111;\n        let b: Field = 222;\n\n        let hash1 = merkle_a_pair(a, b);\n        let hash2 = merkle_a_pair(b, a);\n\n        assert(hash1 != hash2, \"merkle_a_pair should be order-sensitive\");\n    }\n\n    // -------------------------------------------------------------------------\n    // Card Selection Tests\n    // -------------------------------------------------------------------------\n\n    #[test]\n    fn test_get_cards_extracts_first_fifteen() {\n        let deck = fisher_yates_shuffle(777);\n        let cards = get_cards(deck);\n\n        for i in 0..CARDS_TO_DEAL {\n            assert(cards[i] == deck[i], \"get_cards should extract cards in order\");\n        }\n    }\n\n    #[test]\n    fn test_get_cards_returns_correct_count() {\n        let deck = fisher_yates_shuffle(888);\n        let cards = get_cards(deck);\n\n        // Verify we get exactly CARDS_TO_DEAL cards\n        assert(cards.len() == CARDS_TO_DEAL, \"Should return CARDS_TO_DEAL cards\");\n    }\n\n    // -------------------------------------------------------------------------\n    // Integration Tests\n    // -------------------------------------------------------------------------\n\n    #[test]\n    fn test_full_shuffle_and_verify_workflow() {\n        // Simulate the full workflow: shuffle, compute root, extract cards\n        let seed: Field = 0xdeadbeef;\n\n        // Step 1: Shuffle\n        let deck = fisher_yates_shuffle(seed);\n\n        // Step 2: Compute merkle root (for on-chain commitment)\n        let root = merkle_root(deck, seed);\n\n        // Step 3: Extract cards for gameplay\n        let cards = get_cards(deck);\n\n        // Verify: Re-compute and check consistency\n        let deck_verify = fisher_yates_shuffle(seed);\n        let root_verify = merkle_root(deck_verify, seed);\n        let cards_verify = get_cards(deck_verify);\n\n        assert(root == root_verify, \"Root should match on re-computation\");\n        for i in 0..CARDS_TO_DEAL {\n            assert(cards[i] == cards_verify[i], \"Cards should match on re-computation\");\n        }\n    }\n\n    // -------------------------------------------------------------------------\n    // Calculate Commitment Tests\n    // -------------------------------------------------------------------------\n\n    #[test]\n    fn test_calculate_commitment_is_deterministic() {\n        // Same inputs must produce the same commitments\n        let cards: [Field; 10] = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n        let players: [Field; 5] = [100, 200, 300, 400, 500];\n        let player_status: [bool; 5] = [true, true, true, true, true];\n\n        let commitments1 = calculate_commitment(cards, players, player_status);\n        let commitments2 = calculate_commitment(cards, players, player_status);\n\n        for i in 0..10 {\n            assert(commitments1[i] == commitments2[i], \"Commitments must be deterministic\");\n        }\n    }\n\n    #[test]\n    fn test_calculate_commitment_all_players_active() {\n        // When all players are active, all commitments should be non-zero\n        let cards: [Field; 10] = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n        let players: [Field; 5] = [100, 200, 300, 400, 500];\n        let player_status: [bool; 5] = [true, true, true, true, true];\n\n        let commitments = calculate_commitment(cards, players, player_status);\n\n        for i in 0..10 {\n            assert(commitments[i] != 0, \"Active player commitments should be non-zero\");\n        }\n    }\n\n    #[test]\n    fn test_calculate_commitment_all_players_inactive() {\n        // When all players are inactive, all commitments should be zero\n        let cards: [Field; 10] = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n        let players: [Field; 5] = [100, 200, 300, 400, 500];\n        let player_status: [bool; 5] = [false, false, false, false, false];\n\n        let commitments = calculate_commitment(cards, players, player_status);\n\n        for i in 0..10 {\n            assert(commitments[i] == 0, \"Inactive player commitments should be zero\");\n        }\n    }\n\n    #[test]\n    fn test_calculate_commitment_partial_players() {\n        // Mixed active/inactive players\n        let cards: [Field; 10] = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n        let players: [Field; 5] = [100, 200, 300, 400, 500];\n        // Players 0, 2, 4 are active; players 1, 3 are inactive\n        let player_status: [bool; 5] = [true, false, true, false, true];\n\n        let commitments = calculate_commitment(cards, players, player_status);\n\n        // Player 0 (cards 0, 1) - active\n        assert(commitments[0] != 0, \"Player 0 card 0 should have commitment\");\n        assert(commitments[1] != 0, \"Player 0 card 1 should have commitment\");\n\n        // Player 1 (cards 2, 3) - inactive\n        assert(commitments[2] == 0, \"Player 1 card 0 should be zero\");\n        assert(commitments[3] == 0, \"Player 1 card 1 should be zero\");\n\n        // Player 2 (cards 4, 5) - active\n        assert(commitments[4] != 0, \"Player 2 card 0 should have commitment\");\n        assert(commitments[5] != 0, \"Player 2 card 1 should have commitment\");\n\n        // Player 3 (cards 6, 7) - inactive\n        assert(commitments[6] == 0, \"Player 3 card 0 should be zero\");\n        assert(commitments[7] == 0, \"Player 3 card 1 should be zero\");\n\n        // Player 4 (cards 8, 9) - active\n        assert(commitments[8] != 0, \"Player 4 card 0 should have commitment\");\n        assert(commitments[9] != 0, \"Player 4 card 1 should have commitment\");\n    }\n\n    #[test]\n    fn test_calculate_commitment_card_player_mapping() {\n        // Verify that each pair of cards maps to the correct player\n        // Card 0,1 -> Player 0; Card 2,3 -> Player 1; etc.\n        let cards: [Field; 10] = [05, 10, 15, 20, 25, 30, 35, 40, 45, 50];\n        let players: [Field; 5] = [1, 2, 3, 4, 5];\n        let player_status: [bool; 5] = [true, true, true, true, true];\n\n        let commitments = calculate_commitment(cards, players, player_status);\n\n        // Manually verify the expected commitment hashes\n        // commitment[i] = Poseidon2::hash([cards[i], players[i/2]], 2)\n        let expected_0 = Poseidon2::hash([05, 1], 2); // card 0, player 0\n        let expected_1 = Poseidon2::hash([10, 1], 2); // card 1, player 0\n        let expected_2 = Poseidon2::hash([15, 2], 2); // card 2, player 1\n        let expected_3 = Poseidon2::hash([20, 2], 2); // card 3, player 1\n        let expected_4 = Poseidon2::hash([25, 3], 2); // card 4, player 2\n        let expected_5 = Poseidon2::hash([30, 3], 2); // card 5, player 2\n        let expected_6 = Poseidon2::hash([35, 4], 2); // card 6, player 3\n        let expected_7 = Poseidon2::hash([40, 4], 2); // card 7, player 3\n        let expected_8 = Poseidon2::hash([45, 5], 2); // card 8, player 4\n        let expected_9 = Poseidon2::hash([50, 5], 2); // card 9, player 4\n\n        assert(commitments[0] == expected_0, \"Card 0 commitment mismatch\");\n        assert(commitments[1] == expected_1, \"Card 1 commitment mismatch\");\n        assert(commitments[2] == expected_2, \"Card 2 commitment mismatch\");\n        assert(commitments[3] == expected_3, \"Card 3 commitment mismatch\");\n        assert(commitments[4] == expected_4, \"Card 4 commitment mismatch\");\n        assert(commitments[5] == expected_5, \"Card 5 commitment mismatch\");\n        assert(commitments[6] == expected_6, \"Card 6 commitment mismatch\");\n        assert(commitments[7] == expected_7, \"Card 7 commitment mismatch\");\n        assert(commitments[8] == expected_8, \"Card 8 commitment mismatch\");\n        assert(commitments[9] == expected_9, \"Card 9 commitment mismatch\");\n    }\n\n    #[test]\n    fn test_calculate_commitment_different_players_different_commitments() {\n        // Same card with different players should produce different commitments\n        let cards: [Field; 10] = [42, 42, 42, 42, 42, 42, 42, 42, 42, 42]; // all same card\n        let players: [Field; 5] = [1, 2, 3, 4, 5]; // different players\n        let player_status: [bool; 5] = [true, true, true, true, true];\n\n        let commitments = calculate_commitment(cards, players, player_status);\n\n        // Commitments for the same card but different players should differ\n        // Group by player: (0,1), (2,3), (4,5), (6,7), (8,9)\n        // Compare commitments across different player groups\n        assert(\n            commitments[0] != commitments[2],\n            \"Different players should have different commitments\",\n        );\n        assert(\n            commitments[2] != commitments[4],\n            \"Different players should have different commitments\",\n        );\n        assert(\n            commitments[4] != commitments[6],\n            \"Different players should have different commitments\",\n        );\n        assert(\n            commitments[6] != commitments[8],\n            \"Different players should have different commitments\",\n        );\n    }\n\n    #[test]\n    fn test_calculate_commitment_different_cards_same_player() {\n        // Different cards for the same player should produce different commitments\n        let cards: [Field; 10] = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]; // different cards\n        let players: [Field; 5] = [100, 100, 100, 100, 100]; // all same player\n        let player_status: [bool; 5] = [true, true, true, true, true];\n\n        let commitments = calculate_commitment(cards, players, player_status);\n\n        // Each card should produce a unique commitment\n        for i in 0..10 {\n            for j in (i + 1)..10 {\n                assert(\n                    commitments[i] != commitments[j],\n                    \"Different cards should have different commitments\",\n                );\n            }\n        }\n    }\n\n    #[test]\n    fn test_calculate_commitment_with_zero_values() {\n        // Edge case: zero-valued cards and players\n        let cards: [Field; 10] = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\n        let players: [Field; 5] = [0, 0, 0, 0, 0];\n        let player_status: [bool; 5] = [true, true, true, true, true];\n\n        let commitments = calculate_commitment(cards, players, player_status);\n\n        // All commitments should be the same since all inputs are identical\n        let expected = Poseidon2::hash([0, 0], 2);\n        for i in 0..10 {\n            assert(commitments[i] == expected, \"Zero values should still produce valid hash\");\n        }\n    }\n\n    #[test]\n    fn test_calculate_commitment_single_player_active() {\n        // Only one player is active\n        let cards: [Field; 10] = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n        let players: [Field; 5] = [100, 200, 300, 400, 500];\n        let player_status: [bool; 5] = [false, false, true, false, false]; // only player 2 active\n\n        let commitments = calculate_commitment(cards, players, player_status);\n\n        // Only cards 4 and 5 (belonging to player 2) should have commitments\n        assert(commitments[0] == 0, \"Player 0 should be inactive\");\n        assert(commitments[1] == 0, \"Player 0 should be inactive\");\n        assert(commitments[2] == 0, \"Player 1 should be inactive\");\n        assert(commitments[3] == 0, \"Player 1 should be inactive\");\n        assert(commitments[4] != 0, \"Player 2 card 0 should have commitment\");\n        assert(commitments[5] != 0, \"Player 2 card 1 should have commitment\");\n        assert(commitments[6] == 0, \"Player 3 should be inactive\");\n        assert(commitments[7] == 0, \"Player 3 should be inactive\");\n        assert(commitments[8] == 0, \"Player 4 should be inactive\");\n        assert(commitments[9] == 0, \"Player 4 should be inactive\");\n    }\n\n    // -------------------------------------------------------------------------\n    // Reveal Circuit Integration Test\n    // -------------------------------------------------------------------------\n\n    #[test]\n    fn test_commitment_verification_workflow() {\n        // Simulates the reveal circuit verification workflow\n        let cards: [Field; 10] = [5, 15, 25, 35, 45, 10, 20, 30, 40, 50];\n        let players: [Field; 5] = [0xAAA, 0xBBB, 0xCCC, 0xDDD, 0xEEE];\n        let player_status: [bool; 5] = [true, true, true, true, true];\n\n        // Step 1: Calculate commitments (done during deal phase)\n        let onchain_commitments = calculate_commitment(cards, players, player_status);\n\n        // Step 2: Later, recalculate commitments (done during reveal phase)\n        let reveal_commitments = calculate_commitment(cards, players, player_status);\n\n        // Step 3: Verify they match (as the reveal circuit would do)\n        for i in 0..player_status.len() {\n            if player_status[i] {\n                assert(\n                    reveal_commitments[2 * i] == onchain_commitments[2 * i],\n                    \"Card commitment mismatch at showdown\",\n                );\n                assert(\n                    reveal_commitments[2 * i + 1] == onchain_commitments[2 * i + 1],\n                    \"Card commitment mismatch at showdown for player\",\n                );\n            }\n        }\n    }\n\n    // -------------------------------------------------------------------------\n    // Calculate Community Commitment Tests\n    // -------------------------------------------------------------------------\n\n    #[test]\n    fn test_calculate_community_commitment_is_deterministic() {\n        // Same inputs must produce the same commitment\n        let cards: [Field; 5] = [10, 20, 30, 40, 50];\n\n        let commitment1 = calculate_community_commitment(cards);\n        let commitment2 = calculate_community_commitment(cards);\n\n        assert(commitment1 == commitment2, \"Community commitment must be deterministic\");\n    }\n\n    #[test]\n    fn test_calculate_community_commitment_different_cards() {\n        // Different community cards should produce different commitments\n        let cards1: [Field; 5] = [1, 2, 3, 4, 5];\n        let cards2: [Field; 5] = [6, 7, 8, 9, 10];\n\n        let commitment1 = calculate_community_commitment(cards1);\n        let commitment2 = calculate_community_commitment(cards2);\n\n        assert(commitment1 != commitment2, \"Different cards should produce different commitments\");\n    }\n\n    #[test]\n    fn test_calculate_community_commitment_order_matters() {\n        // The order of cards affects the commitment (important for flop, turn, river)\n        let cards1: [Field; 5] = [1, 2, 3, 4, 5];\n        let cards2: [Field; 5] = [5, 4, 3, 2, 1]; // reversed order\n\n        let commitment1 = calculate_community_commitment(cards1);\n        let commitment2 = calculate_community_commitment(cards2);\n\n        assert(commitment1 != commitment2, \"Card order should affect commitment\");\n    }\n\n    #[test]\n    fn test_calculate_community_commitment_integration_with_dealing() {\n        // Full workflow: shuffle -> get cards -> extract community cards -> commit\n        let seed: Field = 0xc0ffee;\n        let deck = fisher_yates_shuffle(seed);\n        let dealt_cards = get_cards(deck);\n\n        // Community cards are the last 5 of the 15 dealt cards (indices 10-14)\n        let community_cards: [Field; 5] =\n            [dealt_cards[10], dealt_cards[11], dealt_cards[12], dealt_cards[13], dealt_cards[14]];\n\n        // Calculate commitment\n        let commitment1 = calculate_community_commitment(community_cards);\n\n        // Re-run the entire workflow for verification\n        let deck_verify = fisher_yates_shuffle(seed);\n        let dealt_verify = get_cards(deck_verify);\n        let community_verify: [Field; 5] = [\n            dealt_verify[10],\n            dealt_verify[11],\n            dealt_verify[12],\n            dealt_verify[13],\n            dealt_verify[14],\n        ];\n        let commitment2 = calculate_community_commitment(community_verify);\n\n        assert(commitment1 == commitment2, \"Community commitment should be reproducible from seed\");\n    }\n\n    #[test]\n    fn test_calculate_community_commitment_unique_for_different_deals() {\n        // Different shuffles should produce different community commitments\n        let deck1 = fisher_yates_shuffle(111);\n        let deck2 = fisher_yates_shuffle(222);\n\n        let cards1 = get_cards(deck1);\n        let cards2 = get_cards(deck2);\n\n        let community1: [Field; 5] = [cards1[10], cards1[11], cards1[12], cards1[13], cards1[14]];\n        let community2: [Field; 5] = [cards2[10], cards2[11], cards2[12], cards2[13], cards2[14]];\n\n        let commitment1 = calculate_community_commitment(community1);\n        let commitment2 = calculate_community_commitment(community2);\n\n        assert(\n            commitment1 != commitment2,\n            \"Different shuffles should produce different community commitments\",\n        );\n    }\n}\n","path":"/home/ally/DevEnv/pvtDock/KH/poker-solana/backend/src/services/circuitry/assist/src/lib.nr"},"59":{"source":"use std::default::Default;\nuse std::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        self.state[0] += self.cache[0];\n        self.state[1] += self.cache[1];\n        self.state[2] += self.cache[2];\n        self.state = crate::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut state = [0; 4];\n        state[RATE] = iv;\n\n        if std::runtime::is_unconstrained() {\n            for i in 0..(in_len / RATE) {\n                state[0] += input[i * RATE];\n                state[1] += input[i * RATE + 1];\n                state[2] += input[i * RATE + 2];\n                state = crate::poseidon2_permutation(state, 4);\n            }\n\n            // handle remaining elements after last full RATE-sized chunk\n            let remainder_start = (in_len / RATE) * RATE;\n            for j in remainder_start..in_len {\n                state[j - remainder_start] += input[j];\n            }\n        } else {\n            let mut states: [[Field; 4]; N / RATE + 1] = [[0; 4]; N / RATE + 1];\n            states[0] = state;\n\n            // process all full RATE-sized chunks, storing state after each permutation\n            for chunk_idx in 0..(N / RATE) {\n                for i in 0..RATE {\n                    state[i] += input[chunk_idx * RATE + i];\n                }\n                state = crate::poseidon2_permutation(state, 4);\n                states[chunk_idx + 1] = state;\n            }\n\n            // get state at the last full block before in_len\n            let first_partially_filled_chunk = in_len / RATE;\n            state = states[first_partially_filled_chunk];\n\n            // handle remaining elements after last full RATE-sized chunk\n            let remainder_start = (in_len / RATE) * RATE;\n            for j in 0..RATE {\n                let idx = remainder_start + j;\n                if idx < in_len {\n                    state[j] += input[idx];\n                }\n            }\n        }\n\n        // always run final permutation unless we just completed a full chunk\n        // still need to permute once if in_len is 0\n        if (in_len == 0) | (in_len % RATE != 0) {\n            state = crate::poseidon2_permutation(state, 4)\n        };\n\n        state[0]\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n","path":"/home/ally/nargo/github.com/noir-lang/poseidon/v0.2.2/src/poseidon2.nr"}}};

export async function fisher_yates_shuffle(seed: Field, foreignCallHandler?: ForeignCallHandler): Promise<Field[]> {
  const program = new Noir(fisher_yates_shuffle_circuit);
  const args: InputMap = { seed };
  const { returnValue } = await program.execute(args, foreignCallHandler);
  return returnValue as Field[];
}
export type get_cardsInputType = {
  deck: Field[];
}

export type get_cardsReturnType = Field[];
export const get_cards_circuit: CompiledCircuit = {"abi":{"parameters":[{"name":"deck","type":{"kind":"array","length":52,"type":{"kind":"field"}},"visibility":"private"}],"return_type":{"abi_type":{"kind":"array","length":15,"type":{"kind":"field"}},"visibility":"private"},"error_types":{}},"bytecode":"H4sIAAAAAAAA/72WuUpDQRSG/8Q1aoz7vq+Ja2LivsWIYCWWNiJixFaijWUeQXwBn0L0cdJZ2tj7/3iLiyk8EDgHPoYLc+EbZuY/E8FvxYLx7vbx6ua6VHwo8COB6ooG40QwpotnpUrmNfV+fvJWLl9cJrOfp08f98/Hle+Xrz9z/6lIzj63JqcI7E7r8HGKwu60AR+nOtidNuHjVA+70xZ8nBpgd9qGj1Mj7E478HFqgt1pFz5OzbA77cHHKQa70z58nFpgdzqAj1Mr7E6H8HFqg90pDx+nOOxOR/BxaofdqWCfi1z4x8BLfUx9QzmtXFQO6d7rnulc6xxp3+KBl949HaSTdJFu0kN6SR/pJwNkkAyRYTJCRskYGQ98J8kUmSYzZJbMkXmSJCmyQBbJElkmK2SVpEmGrJFsaE2J0Dr1NtFbQL1XvU69RVmu7FRWKRt0F3X280R7W0B1/QCrteZWBQoAAA==","debug_symbols":"jZDRCoMwDEX/pc8+qMPh/JUxJNYohdCW2ApD/PdFUecGgz2lN6f3QDupFpvY18Z2blDVfVINGyLT1+Q0BOOsbKc5UXusAyPKSp24tDww2qAqG4kSNQLF9dLgwa4zAAtNE4W2lSnCzhAupzl5t9Pf1aLMb1u7KC/XQ1Bk/xuy8jDkn4aHJNCGv189AhtoCLfYRatPNDz9TvZf8+w0tpFxMa1M3C8=","file_map":{}};

export async function get_cards(deck: Field[], foreignCallHandler?: ForeignCallHandler): Promise<Field[]> {
  const program = new Noir(get_cards_circuit);
  const args: InputMap = { deck };
  const { returnValue } = await program.execute(args, foreignCallHandler);
  return returnValue as Field[];
}
export type merkle_rootInputType = {
  deck: Field[];
  seed: Field;
}

export type merkle_rootReturnType = Field;
export const merkle_root_circuit: CompiledCircuit = {"abi":{"parameters":[{"name":"deck","type":{"kind":"array","length":52,"type":{"kind":"field"}},"visibility":"private"},{"name":"seed","type":{"kind":"field"},"visibility":"private"}],"return_type":{"abi_type":{"kind":"field"},"visibility":"private"},"error_types":{}},"bytecode":"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","debug_symbols":"tZjbbuJIFEX/xc88eJ86py75ldEoIglpISES0TDSKMq/j4G9K50HWyhoXqhKub16YdcyiI/hZfN0+vW43b++/R4e/voYng7b3W7763H39rw+bt/20+rH52rQn4/Hw2YzLQ1/HJ/Oel8fNvvj8LA/7Xar4Z/17nT5R7/f1/vLeFwfpqPjatjsX6ZxAr5ud5vz7HP1dfY4f6qP0Xi2jyV3QOAbAQuEFpmEGDHOEWyekMIISK18nd++nZ8Wzvem95Bi/BGh5CJCHWOOEAtXoSJ0HWtYJ+B2h2q5OySfc1i6l5Z0Iadpm7sTiwR4J0SdI7R5Qhh0JcNqmd1P453bAQs70mq/m5NC/AjRQlFZq3UWke7eEUsWN27smxGGHyFui+N83//Pa3F/Hl8byx0x+6C6d2va/Xd06V0Uh95FqbOJ2sLODO+XMjxmnxPm916IuPtCLCJu25d2/75ctFjYl39Pf62ft4dvH/rDODxMZ+DyapfXdHn16f+dLnlchzwNdTWU61Cvi+06YLyuAhyN64mjcz04Zq6ThsqRPBs5kmfGkTyjmpFnlLPCdepZu64n+iVc1xP9UuI6/RLfa6Jfol+iX6Kf08/p5/Rz+jn9nH5OP6ef08/pF/QL+gX9gn5Bv6Bf0C/oF/QL+mX6Zfpl+mX6Zfpl+mX6Zfpl+mX6FfoV+hX6FfoV+hX6FfoV+hX6FfpV+lX6VfpV+lX6VfpV+lX6VfpV+jX6Nfo1+jX6Nfo1+jX6Nfo1+rW+n0dNtKNH00R7enRNtKvHrEnRoapJUyE9Fbqix4KkQ8oFoUMKphfTk1EzUDSwXqGc1Q0UDlQOlA7UDhQPVA+UD9QPUg9czkoIagiKCKoIygjqCAoJKglKCd6fHXJWTVBOUE9QUFBRUFJQU1BUUFWI/liSs8KCyoLSgtqC4oLqgvKC+oICQ+5PPDmrMSgyqDIoM6gzKDSoNCg1qDWU/jCVs3KDeoOCg4qDkoOag6KDqoOyg7qDwoPKg9KD2oPig+qD8oP6gwKECkTrHwH9M0AfAmrQ1KCpQVODpgZNDZoaNDVoatDUoJ0btMvENEmauCahSdakaFI1aZycG7xORDaRTWQT2UQ2kU1kE9lETiInkZPISeQkchI5iZxETiInkV1kF9lFdpFdZBfZRXaRXWQXOUQOkUPkEDlEDpFD5BA5RA6Rs8hZ5CxyFjmLnC/kz/NXpsN2/bTb8KeO19P++Y9fPo7/vuuIfht5P7w9b15Oh835C9Pl2PQV6j8=","file_map":{"19":{"source":"// Exposed only for usage in `std::meta`\npub(crate) mod poseidon2;\n\nuse crate::default::Default;\nuse crate::embedded_curve_ops::{\n    EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_array_return,\n};\nuse crate::meta::derive_via;\n\n#[foreign(sha256_compression)]\n// docs:start:sha256_compression\npub fn sha256_compression(input: [u32; 16], state: [u32; 8]) -> [u32; 8] {}\n// docs:end:sha256_compression\n\n#[foreign(keccakf1600)]\n// docs:start:keccakf1600\npub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {}\n// docs:end:keccakf1600\n\npub mod keccak {\n    #[deprecated(\"This function has been moved to std::hash::keccakf1600\")]\n    pub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {\n        super::keccakf1600(input)\n    }\n}\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{\n    if crate::runtime::is_unconstrained() {\n        // Temporary measure while Barretenberg is main proving system.\n        // Please open an issue if you're working on another proving system and running into problems due to this.\n        crate::static_assert(\n            N <= 1024,\n            \"Barretenberg cannot prove blake3 hashes with inputs larger than 1024 bytes\",\n        );\n    }\n    __blake3(input)\n}\n\n#[foreign(blake3)]\nfn __blake3<let N: u32>(input: [u8; N]) -> [u8; 32] {}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\n#[inline_always]\npub fn pedersen_commitment_with_separator<let N: u32>(\n    input: [Field; N],\n    separator: u32,\n) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        // we use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        points[i] = from_field_unsafe(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    multi_scalar_mul(generators, points)\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[no_predicates]\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let mut scalars: [EmbeddedCurveScalar; N + 1] = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N + 1];\n    let mut generators: [EmbeddedCurvePoint; N + 1] =\n        [EmbeddedCurvePoint::point_at_infinity(); N + 1];\n    let domain_generators: [EmbeddedCurvePoint; N] =\n        derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n\n    for i in 0..N {\n        scalars[i] = from_field_unsafe(input[i]);\n        generators[i] = domain_generators[i];\n    }\n    scalars[N] = EmbeddedCurveScalar { lo: N as Field, hi: 0 as Field };\n\n    let length_generator: [EmbeddedCurvePoint; 1] =\n        derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    generators[N] = length_generator[0];\n    multi_scalar_mul_array_return(generators, scalars, true)[0].x\n}\n\n#[field(bn254)]\n#[inline_always]\npub fn derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    // TODO(https://github.com/noir-lang/noir/issues/5672): Add back assert_constant on starting_index\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {}\n\n#[field(bn254)]\n// Decompose the input 'bn254 scalar' into two 128 bits limbs.\n// It is called 'unsafe' because it does not assert the limbs are 128 bits\n// Assuming the limbs are 128 bits:\n// Assert the decomposition does not overflow the field size.\nfn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {\n    // Safety: xlo and xhi decomposition is checked below\n    let (xlo, xhi) = unsafe { crate::field::bn254::decompose_hint(scalar) };\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);\n    // Check that the decomposition does not overflow the field size\n    let (a, b) = if xhi == crate::field::bn254::PHI {\n        (xlo, crate::field::bn254::PLO)\n    } else {\n        (xhi, crate::field::bn254::PHI)\n    };\n    crate::field::bn254::assert_lt(a, b);\n\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n\npub fn poseidon2_permutation<let N: u32>(input: [Field; N], state_len: u32) -> [Field; N] {\n    assert_eq(input.len(), state_len);\n    poseidon2_permutation_internal(input)\n}\n\n#[foreign(poseidon2_permutation)]\nfn poseidon2_permutation_internal<let N: u32>(input: [Field; N]) -> [Field; N] {}\n\n// Generic hashing support.\n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\n#[derive_via(derive_hash)]\npub trait Hash {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher;\n}\n\n// docs:start:derive_hash\ncomptime fn derive_hash(s: TypeDefinition) -> Quoted {\n    let name = quote { $crate::hash::Hash };\n    let signature = quote { fn hash<H>(_self: Self, _state: &mut H) where H: $crate::hash::Hasher };\n    let for_each_field = |name| quote { _self.$name.hash(_state); };\n    crate::meta::make_trait_impl(\n        s,\n        name,\n        signature,\n        for_each_field,\n        quote {},\n        |fields| fields,\n    )\n}\n// docs:end:derive_hash\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\npub trait Hasher {\n    fn finish(self) -> Field;\n\n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\npub trait BuildHasher {\n    type H: Hasher;\n\n    fn build_hasher(self) -> H;\n}\n\npub struct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    type H = H;\n\n    fn build_hasher(_self: Self) -> H {\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn default() -> Self {\n        BuildHasherDefault {}\n    }\n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u1 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u128 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u8 as Field);\n    }\n}\n\nimpl Hash for i16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u16 as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u32 as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u64 as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H)\n    where\n        H: Hasher,\n    {}\n}\n\nimpl<T, let N: u32> Hash for [T; N]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B)\nwhere\n    A: Hash,\n    B: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n    E: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n// Some test vectors for Pedersen hash and Pedersen Commitment.\n// They have been generated using the same functions so the tests are for now useless\n// but they will be useful when we switch to Noir implementation.\n#[test]\nfn assert_pedersen() {\n    assert_eq(\n        pedersen_hash_with_separator([1], 1),\n        0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1], 1),\n        EmbeddedCurvePoint {\n            x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,\n            y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,\n            is_infinite: false,\n        },\n    );\n\n    assert_eq(\n        pedersen_hash_with_separator([1, 2], 2),\n        0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2], 2),\n        EmbeddedCurvePoint {\n            x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,\n            y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3], 3),\n        0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3], 3),\n        EmbeddedCurvePoint {\n            x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,\n            y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4], 4),\n        0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4], 4),\n        EmbeddedCurvePoint {\n            x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,\n            y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5),\n        0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5),\n        EmbeddedCurvePoint {\n            x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,\n            y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6),\n        0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6),\n        EmbeddedCurvePoint {\n            x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,\n            y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        EmbeddedCurvePoint {\n            x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,\n            y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        EmbeddedCurvePoint {\n            x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,\n            y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        EmbeddedCurvePoint {\n            x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,\n            y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        EmbeddedCurvePoint {\n            x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,\n            y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,\n            is_infinite: false,\n        },\n    );\n}\n","path":"std/hash/mod.nr"},"51":{"source":"use poseidon::poseidon2::Poseidon2;\nuse std::field::bn254::assert_lt;\n\n/// Number of cards in a standard deck.\npub global DECK_SIZE: u32 = 52;\n\n/// Number of cards to deal for gameplay (5 players * 2 cards + 5 community cards = 15).\npub global CARDS_TO_DEAL: u32 = 15;\n\n// Domain separators prevent cross-protocol hash collisions.\npub global HASH_DOMAIN_SEPARATOR_SEED: Field = 1;\npub global HASH_DOMAIN_SEPARATOR_DECK: Field = 2;\npub global HASH_DOMAIN_SEPARATOR_CARD: Field = 3;\n\n/// Domain separator for Fisher-Yates RNG state transitions.\npub global HASH_DOMAIN_SEPARATOR_RNG: Field = 4;\npub global PADDING_NONCE: Field = 5;\n\n/// Performs a deterministic Fisher-Yates shuffle on a 52-card deck.\n///\n/// # Arguments\n/// * `seed` - Random seed from on-chain randomness source.\n///\n/// # Returns\n/// A shuffled deck represented as an array of Field elements (0-51).\n///\n/// # Security Properties\n/// - Deterministic: Same seed always produces the same shuffle.\n/// - Uniform: Each permutation is equally likely given a uniformly random seed.\n/// - Verifiable: The shuffle can be independently verified with the seed.\n#[export]\npub fn fisher_yates_shuffle(seed: Field) -> [Field; DECK_SIZE] {\n    // Initialize the deck as 0-51 indices\n    let mut deck = [0; DECK_SIZE];\n    for i in 0..DECK_SIZE {\n        deck[i] = i as Field;\n    }\n\n    // Initialize the RNG state with the random seed using domain separator\n    let mut rng_state = Poseidon2::hash([HASH_DOMAIN_SEPARATOR_RNG, seed], 2);\n\n    // Perform the Fisher-Yates shuffle\n    // Iterate from the last element down to the second element\n    for i in 0..(DECK_SIZE - 1) {\n        let idx = (DECK_SIZE - 1) - i;\n\n        // Generate random hash with domain-separated RNG state update\n        rng_state = Poseidon2::hash([HASH_DOMAIN_SEPARATOR_RNG, rng_state, idx as Field], 3);\n\n        // Calculate the swap index unconstrained\n        let range = (idx + 1) as Field;\n        // Safety: constraints enabled by proceeding assertions\n        let (quotient, remainder) = unsafe { divide_hint(rng_state, range) };\n\n        // Constrain the division result: rng_state = quotient * range + remainder\n        assert(rng_state == quotient * range + remainder);\n        // Ensure remainder is in valid range [0, range)\n        assert_lt(remainder, range);\n\n        let swap_idx = remainder as u32;\n\n        // Perform the swap\n        if swap_idx != idx {\n            let temp = deck[idx];\n            deck[idx] = deck[swap_idx];\n            deck[swap_idx] = temp;\n        }\n    }\n\n    deck\n}\n\n/// Unconstrained hint for field division.\n/// Computes (quotient, remainder) such that numerator = quotient * denominator + remainder.\nunconstrained fn divide_hint(numerator: Field, denominator: Field) -> (Field, Field) {\n    // NOTE: assuming denominator is small enough to fit in u32 (as is the case for a DECK_SIZE of 52)\n    let den_u64 = denominator as u64;\n    // Minimal check to avoid division by zero\n    assert(den_u64 != 0);\n    // Ensure denominator fits in u32 to guarantee 'remainder * 256' fits in u64\n    assert(den_u64 <= 4294967295);\n\n    let bytes: [u8; 32] = numerator.to_be_bytes();\n    let mut remainder: u64 = 0;\n    let mut quotient: Field = 0;\n\n    for i in 0..32 {\n        let b = bytes[i] as u64;\n        let val = remainder * 256 + b;\n        let q_digit = val / den_u64;\n        let r_digit = val % den_u64;\n\n        quotient = quotient * 256 + (q_digit as Field);\n        remainder = r_digit;\n    }\n    (quotient, remainder as Field)\n}\n\n/// Computes the Merkle root of a shuffled deck.\n///\n/// # Arguments\n/// * `deck` - The shuffled deck array.\n/// * `seed` - The shuffle seed (used to derive salt for binding).\n///\n/// # Returns\n/// The Merkle root hash of the deck.\n///\n/// # Implementation Notes\n/// - Uses a 64-leaf tree (52 cards + 12 padding leaves).\n/// - Each card is hashed with its position and a seed-derived salt.\n#[export]\npub fn merkle_root(deck: [Field; DECK_SIZE], seed: Field) -> Field {\n    // Generate salt for binding cards to this specific shuffle\n    let salt = derive_salt(seed);\n\n    // Hash all cards directly into buffer\n    let mut buffer: [Field; 64] = [0; 64];\n\n    for i in 0..DECK_SIZE {\n        buffer[i] = hash_card_in_deck(deck[i], i as Field, salt);\n    }\n\n    // Pad buffer with a fixed value to reach power of 2 tree size\n    let padding = Poseidon2::hash([HASH_DOMAIN_SEPARATOR_DECK, PADDING_NONCE], 2);\n    for i in DECK_SIZE..64 {\n        buffer[i] = padding;\n    }\n\n    // Build tree bottom-up, reusing buffer space\n    // After each level, results are stored in the first half of the buffer\n    let mut size = 64;\n    for _ in 0..6 {\n        let next_size = size / 2;\n        for i in 0..next_size {\n            buffer[i] = merkle_a_pair(buffer[i * 2], buffer[i * 2 + 1]);\n        }\n        size = next_size;\n    }\n\n    buffer[0]\n}\n\n/// Derives a salt from the shuffle seed for card hashing.\npub fn derive_salt(seed: Field) -> Field {\n    Poseidon2::hash([seed, HASH_DOMAIN_SEPARATOR_CARD], 2)\n}\n\n/// Hashes a card at a specific position with salt.\n/// The position ensures uniqueness even for duplicate card values.\npub fn hash_card_in_deck(card: Field, position: Field, salt: Field) -> Field {\n    Poseidon2::hash([HASH_DOMAIN_SEPARATOR_CARD, card, position, salt], 4)\n}\n\n/// Hashes two child nodes to produce a parent node in the Merkle tree.\npub fn merkle_a_pair(left: Field, right: Field) -> Field {\n    Poseidon2::hash([left, right], 2)\n}\n\n/// Extracts the first CARDS_TO_DEAL cards from the shuffled deck.\n///\n/// # Arguments\n/// * `deck` - The shuffled deck array.\n///\n/// # Returns\n/// An array of the first 15 cards for gameplay.\n#[export]\npub fn get_cards(deck: [Field; DECK_SIZE]) -> [Field; CARDS_TO_DEAL] {\n    let mut cards = [0; CARDS_TO_DEAL];\n    for i in 0..CARDS_TO_DEAL {\n        cards[i] = deck[i];\n    }\n    cards\n}\n\n/// Commitments of card allocations to respective players\n///\n/// # Arguments\n/// * `cards` - The cards array.\n/// * `players` - The players array.\n/// * `player_status` - The player status array - if player is not in the game, commitment is 0\n///\n/// # Returns\n/// An array of commitments for the cards.\n#[export]\npub fn calculate_commitment(\n    cards: [Field; 10],\n    players: [Field; 5],\n    player_status: [bool; 5],\n) -> [Field; 10] {\n    let mut commitments: [Field; 10] = [0; 10];\n    let mut k = 0;\n\n    for i in 0..cards.len() {\n        let player: Field = players[k];\n\n        commitments[i] = if player_status[k] {\n            Poseidon2::hash([cards[i], player], 2)\n        } else {\n            0\n        };\n\n        if (i % 2 != 0) {\n            k += 1;\n        }\n    }\n\n    commitments\n}\n\n/// Commitment of community cards\n///\n/// # Arguments\n/// * `cards` - The cards array.\n///\n/// # Returns\n/// The commitment for the community cards.\n#[export]\npub fn calculate_community_commitment(cards: [Field; 5]) -> Field {\n    Poseidon2::hash([cards[0], cards[1], cards[2], cards[3], cards[4]], 5)\n}\n\n// =============================================================================\n// Test Module\n// =============================================================================\n\nmod tests {\n    use super::{\n        calculate_commitment, calculate_community_commitment, CARDS_TO_DEAL, DECK_SIZE, derive_salt,\n        fisher_yates_shuffle, get_cards, hash_card_in_deck, merkle_a_pair, merkle_root,\n    };\n    use poseidon::poseidon2::Poseidon2;\n\n    // -------------------------------------------------------------------------\n    // Fisher-Yates Shuffle Tests\n    // -------------------------------------------------------------------------\n\n    #[test]\n    fn test_shuffle_produces_valid_permutation() {\n        // A valid permutation contains each card exactly once\n        let seed: Field = 12345;\n        let deck = fisher_yates_shuffle(seed);\n\n        // Check that all cards 0-51 appear exactly once\n        let mut card_count: [u32; DECK_SIZE] = [0; DECK_SIZE];\n        for i in 0..DECK_SIZE {\n            let card_idx = deck[i] as u32;\n            assert(card_idx < DECK_SIZE, \"Card index out of bounds\");\n            card_count[card_idx] += 1;\n        }\n\n        for i in 0..DECK_SIZE {\n            assert(card_count[i] == 1, \"Each card must appear exactly once\");\n        }\n    }\n\n    #[test]\n    fn test_shuffle_is_deterministic() {\n        // Same seed must produce the same shuffle\n        let seed: Field = 0xabcdef123456;\n        let deck1 = fisher_yates_shuffle(seed);\n        let deck2 = fisher_yates_shuffle(seed);\n\n        for i in 0..DECK_SIZE {\n            assert(deck1[i] == deck2[i], \"Shuffle must be deterministic\");\n        }\n    }\n\n    #[test]\n    fn test_shuffle_different_seeds_produce_different_decks() {\n        let deck1 = fisher_yates_shuffle(1);\n        let deck2 = fisher_yates_shuffle(2);\n\n        // At least one card should be in a different position\n        let mut has_difference = false;\n        for i in 0..DECK_SIZE {\n            if deck1[i] != deck2[i] {\n                has_difference = true;\n            }\n        }\n        assert(has_difference, \"Different seeds should produce different shuffles\");\n    }\n\n    #[test]\n    fn test_shuffle_with_zero_seed() {\n        // Zero seed should still produce a valid permutation\n        let deck = fisher_yates_shuffle(0);\n\n        let mut card_count: [u32; DECK_SIZE] = [0; DECK_SIZE];\n        for i in 0..DECK_SIZE {\n            let card_idx = deck[i] as u32;\n            card_count[card_idx] += 1;\n        }\n\n        for i in 0..DECK_SIZE {\n            assert(card_count[i] == 1, \"Each card must appear exactly once\");\n        }\n    }\n\n    // -------------------------------------------------------------------------\n    // Merkle Root Tests\n    // -------------------------------------------------------------------------\n\n    #[test]\n    fn test_merkle_root_is_deterministic() {\n        let seed: Field = 42;\n        let deck = fisher_yates_shuffle(seed);\n\n        let root1 = merkle_root(deck, seed);\n        let root2 = merkle_root(deck, seed);\n\n        assert(root1 == root2, \"Merkle root must be deterministic\");\n    }\n\n    #[test]\n    fn test_merkle_root_different_decks_produce_different_roots() {\n        let deck1 = fisher_yates_shuffle(100);\n        let deck2 = fisher_yates_shuffle(200);\n\n        let root1 = merkle_root(deck1, 100);\n        let root2 = merkle_root(deck2, 200);\n\n        assert(root1 != root2, \"Different decks should produce different roots\");\n    }\n\n    #[test]\n    fn test_merkle_root_same_deck_different_seed_produces_different_root() {\n        // The seed affects the salt, so same deck with different seeds = different roots\n        let deck = fisher_yates_shuffle(123);\n\n        let root1 = merkle_root(deck, 123);\n        let root2 = merkle_root(deck, 456);\n\n        assert(root1 != root2, \"Same deck with different seeds should produce different roots\");\n    }\n\n    // -------------------------------------------------------------------------\n    // Helper Function Tests\n    // -------------------------------------------------------------------------\n\n    #[test]\n    fn test_derive_salt_is_deterministic() {\n        let seed: Field = 999;\n        let salt1 = derive_salt(seed);\n        let salt2 = derive_salt(seed);\n\n        assert(salt1 == salt2, \"derive_salt must be deterministic\");\n    }\n\n    #[test]\n    fn test_derive_salt_different_seeds_produce_different_salts() {\n        let salt1 = derive_salt(1);\n        let salt2 = derive_salt(2);\n\n        assert(salt1 != salt2, \"Different seeds should produce different salts\");\n    }\n\n    #[test]\n    fn test_hash_card_is_deterministic() {\n        let card: Field = 10;\n        let position: Field = 5;\n        let salt: Field = 12345;\n\n        let hash1 = hash_card_in_deck(card, position, salt);\n        let hash2 = hash_card_in_deck(card, position, salt);\n\n        assert(hash1 == hash2, \"hash_card_in_deck must be deterministic\");\n    }\n\n    #[test]\n    fn test_hash_card_position_affects_hash() {\n        let card: Field = 10;\n        let salt: Field = 12345;\n\n        let hash1 = hash_card_in_deck(card, 0, salt);\n        let hash2 = hash_card_in_deck(card, 1, salt);\n\n        assert(hash1 != hash2, \"Different positions should produce different hashes\");\n    }\n\n    #[test]\n    fn test_merkle_pair_is_deterministic() {\n        let left: Field = 111;\n        let right: Field = 222;\n\n        let hash1 = merkle_a_pair(left, right);\n        let hash2 = merkle_a_pair(left, right);\n\n        assert(hash1 == hash2, \"merkle_a_pair must be deterministic\");\n    }\n\n    #[test]\n    fn test_merkle_pair_order_matters() {\n        let a: Field = 111;\n        let b: Field = 222;\n\n        let hash1 = merkle_a_pair(a, b);\n        let hash2 = merkle_a_pair(b, a);\n\n        assert(hash1 != hash2, \"merkle_a_pair should be order-sensitive\");\n    }\n\n    // -------------------------------------------------------------------------\n    // Card Selection Tests\n    // -------------------------------------------------------------------------\n\n    #[test]\n    fn test_get_cards_extracts_first_fifteen() {\n        let deck = fisher_yates_shuffle(777);\n        let cards = get_cards(deck);\n\n        for i in 0..CARDS_TO_DEAL {\n            assert(cards[i] == deck[i], \"get_cards should extract cards in order\");\n        }\n    }\n\n    #[test]\n    fn test_get_cards_returns_correct_count() {\n        let deck = fisher_yates_shuffle(888);\n        let cards = get_cards(deck);\n\n        // Verify we get exactly CARDS_TO_DEAL cards\n        assert(cards.len() == CARDS_TO_DEAL, \"Should return CARDS_TO_DEAL cards\");\n    }\n\n    // -------------------------------------------------------------------------\n    // Integration Tests\n    // -------------------------------------------------------------------------\n\n    #[test]\n    fn test_full_shuffle_and_verify_workflow() {\n        // Simulate the full workflow: shuffle, compute root, extract cards\n        let seed: Field = 0xdeadbeef;\n\n        // Step 1: Shuffle\n        let deck = fisher_yates_shuffle(seed);\n\n        // Step 2: Compute merkle root (for on-chain commitment)\n        let root = merkle_root(deck, seed);\n\n        // Step 3: Extract cards for gameplay\n        let cards = get_cards(deck);\n\n        // Verify: Re-compute and check consistency\n        let deck_verify = fisher_yates_shuffle(seed);\n        let root_verify = merkle_root(deck_verify, seed);\n        let cards_verify = get_cards(deck_verify);\n\n        assert(root == root_verify, \"Root should match on re-computation\");\n        for i in 0..CARDS_TO_DEAL {\n            assert(cards[i] == cards_verify[i], \"Cards should match on re-computation\");\n        }\n    }\n\n    // -------------------------------------------------------------------------\n    // Calculate Commitment Tests\n    // -------------------------------------------------------------------------\n\n    #[test]\n    fn test_calculate_commitment_is_deterministic() {\n        // Same inputs must produce the same commitments\n        let cards: [Field; 10] = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n        let players: [Field; 5] = [100, 200, 300, 400, 500];\n        let player_status: [bool; 5] = [true, true, true, true, true];\n\n        let commitments1 = calculate_commitment(cards, players, player_status);\n        let commitments2 = calculate_commitment(cards, players, player_status);\n\n        for i in 0..10 {\n            assert(commitments1[i] == commitments2[i], \"Commitments must be deterministic\");\n        }\n    }\n\n    #[test]\n    fn test_calculate_commitment_all_players_active() {\n        // When all players are active, all commitments should be non-zero\n        let cards: [Field; 10] = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n        let players: [Field; 5] = [100, 200, 300, 400, 500];\n        let player_status: [bool; 5] = [true, true, true, true, true];\n\n        let commitments = calculate_commitment(cards, players, player_status);\n\n        for i in 0..10 {\n            assert(commitments[i] != 0, \"Active player commitments should be non-zero\");\n        }\n    }\n\n    #[test]\n    fn test_calculate_commitment_all_players_inactive() {\n        // When all players are inactive, all commitments should be zero\n        let cards: [Field; 10] = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n        let players: [Field; 5] = [100, 200, 300, 400, 500];\n        let player_status: [bool; 5] = [false, false, false, false, false];\n\n        let commitments = calculate_commitment(cards, players, player_status);\n\n        for i in 0..10 {\n            assert(commitments[i] == 0, \"Inactive player commitments should be zero\");\n        }\n    }\n\n    #[test]\n    fn test_calculate_commitment_partial_players() {\n        // Mixed active/inactive players\n        let cards: [Field; 10] = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n        let players: [Field; 5] = [100, 200, 300, 400, 500];\n        // Players 0, 2, 4 are active; players 1, 3 are inactive\n        let player_status: [bool; 5] = [true, false, true, false, true];\n\n        let commitments = calculate_commitment(cards, players, player_status);\n\n        // Player 0 (cards 0, 1) - active\n        assert(commitments[0] != 0, \"Player 0 card 0 should have commitment\");\n        assert(commitments[1] != 0, \"Player 0 card 1 should have commitment\");\n\n        // Player 1 (cards 2, 3) - inactive\n        assert(commitments[2] == 0, \"Player 1 card 0 should be zero\");\n        assert(commitments[3] == 0, \"Player 1 card 1 should be zero\");\n\n        // Player 2 (cards 4, 5) - active\n        assert(commitments[4] != 0, \"Player 2 card 0 should have commitment\");\n        assert(commitments[5] != 0, \"Player 2 card 1 should have commitment\");\n\n        // Player 3 (cards 6, 7) - inactive\n        assert(commitments[6] == 0, \"Player 3 card 0 should be zero\");\n        assert(commitments[7] == 0, \"Player 3 card 1 should be zero\");\n\n        // Player 4 (cards 8, 9) - active\n        assert(commitments[8] != 0, \"Player 4 card 0 should have commitment\");\n        assert(commitments[9] != 0, \"Player 4 card 1 should have commitment\");\n    }\n\n    #[test]\n    fn test_calculate_commitment_card_player_mapping() {\n        // Verify that each pair of cards maps to the correct player\n        // Card 0,1 -> Player 0; Card 2,3 -> Player 1; etc.\n        let cards: [Field; 10] = [05, 10, 15, 20, 25, 30, 35, 40, 45, 50];\n        let players: [Field; 5] = [1, 2, 3, 4, 5];\n        let player_status: [bool; 5] = [true, true, true, true, true];\n\n        let commitments = calculate_commitment(cards, players, player_status);\n\n        // Manually verify the expected commitment hashes\n        // commitment[i] = Poseidon2::hash([cards[i], players[i/2]], 2)\n        let expected_0 = Poseidon2::hash([05, 1], 2); // card 0, player 0\n        let expected_1 = Poseidon2::hash([10, 1], 2); // card 1, player 0\n        let expected_2 = Poseidon2::hash([15, 2], 2); // card 2, player 1\n        let expected_3 = Poseidon2::hash([20, 2], 2); // card 3, player 1\n        let expected_4 = Poseidon2::hash([25, 3], 2); // card 4, player 2\n        let expected_5 = Poseidon2::hash([30, 3], 2); // card 5, player 2\n        let expected_6 = Poseidon2::hash([35, 4], 2); // card 6, player 3\n        let expected_7 = Poseidon2::hash([40, 4], 2); // card 7, player 3\n        let expected_8 = Poseidon2::hash([45, 5], 2); // card 8, player 4\n        let expected_9 = Poseidon2::hash([50, 5], 2); // card 9, player 4\n\n        assert(commitments[0] == expected_0, \"Card 0 commitment mismatch\");\n        assert(commitments[1] == expected_1, \"Card 1 commitment mismatch\");\n        assert(commitments[2] == expected_2, \"Card 2 commitment mismatch\");\n        assert(commitments[3] == expected_3, \"Card 3 commitment mismatch\");\n        assert(commitments[4] == expected_4, \"Card 4 commitment mismatch\");\n        assert(commitments[5] == expected_5, \"Card 5 commitment mismatch\");\n        assert(commitments[6] == expected_6, \"Card 6 commitment mismatch\");\n        assert(commitments[7] == expected_7, \"Card 7 commitment mismatch\");\n        assert(commitments[8] == expected_8, \"Card 8 commitment mismatch\");\n        assert(commitments[9] == expected_9, \"Card 9 commitment mismatch\");\n    }\n\n    #[test]\n    fn test_calculate_commitment_different_players_different_commitments() {\n        // Same card with different players should produce different commitments\n        let cards: [Field; 10] = [42, 42, 42, 42, 42, 42, 42, 42, 42, 42]; // all same card\n        let players: [Field; 5] = [1, 2, 3, 4, 5]; // different players\n        let player_status: [bool; 5] = [true, true, true, true, true];\n\n        let commitments = calculate_commitment(cards, players, player_status);\n\n        // Commitments for the same card but different players should differ\n        // Group by player: (0,1), (2,3), (4,5), (6,7), (8,9)\n        // Compare commitments across different player groups\n        assert(\n            commitments[0] != commitments[2],\n            \"Different players should have different commitments\",\n        );\n        assert(\n            commitments[2] != commitments[4],\n            \"Different players should have different commitments\",\n        );\n        assert(\n            commitments[4] != commitments[6],\n            \"Different players should have different commitments\",\n        );\n        assert(\n            commitments[6] != commitments[8],\n            \"Different players should have different commitments\",\n        );\n    }\n\n    #[test]\n    fn test_calculate_commitment_different_cards_same_player() {\n        // Different cards for the same player should produce different commitments\n        let cards: [Field; 10] = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]; // different cards\n        let players: [Field; 5] = [100, 100, 100, 100, 100]; // all same player\n        let player_status: [bool; 5] = [true, true, true, true, true];\n\n        let commitments = calculate_commitment(cards, players, player_status);\n\n        // Each card should produce a unique commitment\n        for i in 0..10 {\n            for j in (i + 1)..10 {\n                assert(\n                    commitments[i] != commitments[j],\n                    \"Different cards should have different commitments\",\n                );\n            }\n        }\n    }\n\n    #[test]\n    fn test_calculate_commitment_with_zero_values() {\n        // Edge case: zero-valued cards and players\n        let cards: [Field; 10] = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\n        let players: [Field; 5] = [0, 0, 0, 0, 0];\n        let player_status: [bool; 5] = [true, true, true, true, true];\n\n        let commitments = calculate_commitment(cards, players, player_status);\n\n        // All commitments should be the same since all inputs are identical\n        let expected = Poseidon2::hash([0, 0], 2);\n        for i in 0..10 {\n            assert(commitments[i] == expected, \"Zero values should still produce valid hash\");\n        }\n    }\n\n    #[test]\n    fn test_calculate_commitment_single_player_active() {\n        // Only one player is active\n        let cards: [Field; 10] = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n        let players: [Field; 5] = [100, 200, 300, 400, 500];\n        let player_status: [bool; 5] = [false, false, true, false, false]; // only player 2 active\n\n        let commitments = calculate_commitment(cards, players, player_status);\n\n        // Only cards 4 and 5 (belonging to player 2) should have commitments\n        assert(commitments[0] == 0, \"Player 0 should be inactive\");\n        assert(commitments[1] == 0, \"Player 0 should be inactive\");\n        assert(commitments[2] == 0, \"Player 1 should be inactive\");\n        assert(commitments[3] == 0, \"Player 1 should be inactive\");\n        assert(commitments[4] != 0, \"Player 2 card 0 should have commitment\");\n        assert(commitments[5] != 0, \"Player 2 card 1 should have commitment\");\n        assert(commitments[6] == 0, \"Player 3 should be inactive\");\n        assert(commitments[7] == 0, \"Player 3 should be inactive\");\n        assert(commitments[8] == 0, \"Player 4 should be inactive\");\n        assert(commitments[9] == 0, \"Player 4 should be inactive\");\n    }\n\n    // -------------------------------------------------------------------------\n    // Reveal Circuit Integration Test\n    // -------------------------------------------------------------------------\n\n    #[test]\n    fn test_commitment_verification_workflow() {\n        // Simulates the reveal circuit verification workflow\n        let cards: [Field; 10] = [5, 15, 25, 35, 45, 10, 20, 30, 40, 50];\n        let players: [Field; 5] = [0xAAA, 0xBBB, 0xCCC, 0xDDD, 0xEEE];\n        let player_status: [bool; 5] = [true, true, true, true, true];\n\n        // Step 1: Calculate commitments (done during deal phase)\n        let onchain_commitments = calculate_commitment(cards, players, player_status);\n\n        // Step 2: Later, recalculate commitments (done during reveal phase)\n        let reveal_commitments = calculate_commitment(cards, players, player_status);\n\n        // Step 3: Verify they match (as the reveal circuit would do)\n        for i in 0..player_status.len() {\n            if player_status[i] {\n                assert(\n                    reveal_commitments[2 * i] == onchain_commitments[2 * i],\n                    \"Card commitment mismatch at showdown\",\n                );\n                assert(\n                    reveal_commitments[2 * i + 1] == onchain_commitments[2 * i + 1],\n                    \"Card commitment mismatch at showdown for player\",\n                );\n            }\n        }\n    }\n\n    // -------------------------------------------------------------------------\n    // Calculate Community Commitment Tests\n    // -------------------------------------------------------------------------\n\n    #[test]\n    fn test_calculate_community_commitment_is_deterministic() {\n        // Same inputs must produce the same commitment\n        let cards: [Field; 5] = [10, 20, 30, 40, 50];\n\n        let commitment1 = calculate_community_commitment(cards);\n        let commitment2 = calculate_community_commitment(cards);\n\n        assert(commitment1 == commitment2, \"Community commitment must be deterministic\");\n    }\n\n    #[test]\n    fn test_calculate_community_commitment_different_cards() {\n        // Different community cards should produce different commitments\n        let cards1: [Field; 5] = [1, 2, 3, 4, 5];\n        let cards2: [Field; 5] = [6, 7, 8, 9, 10];\n\n        let commitment1 = calculate_community_commitment(cards1);\n        let commitment2 = calculate_community_commitment(cards2);\n\n        assert(commitment1 != commitment2, \"Different cards should produce different commitments\");\n    }\n\n    #[test]\n    fn test_calculate_community_commitment_order_matters() {\n        // The order of cards affects the commitment (important for flop, turn, river)\n        let cards1: [Field; 5] = [1, 2, 3, 4, 5];\n        let cards2: [Field; 5] = [5, 4, 3, 2, 1]; // reversed order\n\n        let commitment1 = calculate_community_commitment(cards1);\n        let commitment2 = calculate_community_commitment(cards2);\n\n        assert(commitment1 != commitment2, \"Card order should affect commitment\");\n    }\n\n    #[test]\n    fn test_calculate_community_commitment_integration_with_dealing() {\n        // Full workflow: shuffle -> get cards -> extract community cards -> commit\n        let seed: Field = 0xc0ffee;\n        let deck = fisher_yates_shuffle(seed);\n        let dealt_cards = get_cards(deck);\n\n        // Community cards are the last 5 of the 15 dealt cards (indices 10-14)\n        let community_cards: [Field; 5] =\n            [dealt_cards[10], dealt_cards[11], dealt_cards[12], dealt_cards[13], dealt_cards[14]];\n\n        // Calculate commitment\n        let commitment1 = calculate_community_commitment(community_cards);\n\n        // Re-run the entire workflow for verification\n        let deck_verify = fisher_yates_shuffle(seed);\n        let dealt_verify = get_cards(deck_verify);\n        let community_verify: [Field; 5] = [\n            dealt_verify[10],\n            dealt_verify[11],\n            dealt_verify[12],\n            dealt_verify[13],\n            dealt_verify[14],\n        ];\n        let commitment2 = calculate_community_commitment(community_verify);\n\n        assert(commitment1 == commitment2, \"Community commitment should be reproducible from seed\");\n    }\n\n    #[test]\n    fn test_calculate_community_commitment_unique_for_different_deals() {\n        // Different shuffles should produce different community commitments\n        let deck1 = fisher_yates_shuffle(111);\n        let deck2 = fisher_yates_shuffle(222);\n\n        let cards1 = get_cards(deck1);\n        let cards2 = get_cards(deck2);\n\n        let community1: [Field; 5] = [cards1[10], cards1[11], cards1[12], cards1[13], cards1[14]];\n        let community2: [Field; 5] = [cards2[10], cards2[11], cards2[12], cards2[13], cards2[14]];\n\n        let commitment1 = calculate_community_commitment(community1);\n        let commitment2 = calculate_community_commitment(community2);\n\n        assert(\n            commitment1 != commitment2,\n            \"Different shuffles should produce different community commitments\",\n        );\n    }\n}\n","path":"/home/ally/DevEnv/pvtDock/KH/poker-solana/backend/src/services/circuitry/assist/src/lib.nr"},"59":{"source":"use std::default::Default;\nuse std::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        self.state[0] += self.cache[0];\n        self.state[1] += self.cache[1];\n        self.state[2] += self.cache[2];\n        self.state = crate::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut state = [0; 4];\n        state[RATE] = iv;\n\n        if std::runtime::is_unconstrained() {\n            for i in 0..(in_len / RATE) {\n                state[0] += input[i * RATE];\n                state[1] += input[i * RATE + 1];\n                state[2] += input[i * RATE + 2];\n                state = crate::poseidon2_permutation(state, 4);\n            }\n\n            // handle remaining elements after last full RATE-sized chunk\n            let remainder_start = (in_len / RATE) * RATE;\n            for j in remainder_start..in_len {\n                state[j - remainder_start] += input[j];\n            }\n        } else {\n            let mut states: [[Field; 4]; N / RATE + 1] = [[0; 4]; N / RATE + 1];\n            states[0] = state;\n\n            // process all full RATE-sized chunks, storing state after each permutation\n            for chunk_idx in 0..(N / RATE) {\n                for i in 0..RATE {\n                    state[i] += input[chunk_idx * RATE + i];\n                }\n                state = crate::poseidon2_permutation(state, 4);\n                states[chunk_idx + 1] = state;\n            }\n\n            // get state at the last full block before in_len\n            let first_partially_filled_chunk = in_len / RATE;\n            state = states[first_partially_filled_chunk];\n\n            // handle remaining elements after last full RATE-sized chunk\n            let remainder_start = (in_len / RATE) * RATE;\n            for j in 0..RATE {\n                let idx = remainder_start + j;\n                if idx < in_len {\n                    state[j] += input[idx];\n                }\n            }\n        }\n\n        // always run final permutation unless we just completed a full chunk\n        // still need to permute once if in_len is 0\n        if (in_len == 0) | (in_len % RATE != 0) {\n            state = crate::poseidon2_permutation(state, 4)\n        };\n\n        state[0]\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n","path":"/home/ally/nargo/github.com/noir-lang/poseidon/v0.2.2/src/poseidon2.nr"}}};

export async function merkle_root(deck: Field[], seed: Field, foreignCallHandler?: ForeignCallHandler): Promise<Field> {
  const program = new Noir(merkle_root_circuit);
  const args: InputMap = { deck, seed };
  const { returnValue } = await program.execute(args, foreignCallHandler);
  return returnValue as Field;
}
