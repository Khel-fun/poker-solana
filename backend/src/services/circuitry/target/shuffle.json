{"noir_version":"1.0.0-beta.18+99bb8b5cf33d7669adbdef096b12d80f30b4c0c9","hash":"11245998177740412217","abi":{"parameters":[{"name":"seed","type":{"kind":"field"},"visibility":"private"},{"name":"root_commitment","type":{"kind":"field"},"visibility":"public"},{"name":"cards","type":{"kind":"array","length":15,"type":{"kind":"field"}},"visibility":"private"}],"return_type":null,"error_types":{"361444214588792908":{"error_kind":"string","string":"attempt to multiply with overflow"},"3696944097111209776":{"error_kind":"string","string":"Deck merkle root does not match commitment"},"5266694954087851722":{"error_kind":"string","string":"Mismatch in the allocated cards"},"12469291177396340830":{"error_kind":"string","string":"call to assert_max_bit_size"},"14990209321349310352":{"error_kind":"string","string":"attempt to add with overflow"},"15764276373176857197":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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","debug_symbols":"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XZv7z8vm/vOyuf+8bO4/L5vnRpXNc6PK5rlRZeR2I7cbuf31cN6VUTnV7HM8XOHhCg9XeLjCwxUervBwhYcrPFzh4QoPV3i4wsMVHq7wcIWHKzxc4eEKD1d4uMLDFR6u8HCFhys8XOHhCg9XeLjCwxUervBwhYcrI7cbud3I7UZuN3K7kduN3G7kdiO3G7ndyO1Gbjdyu5Hbjdxu5HYjtxu53cjtRm43crtxPcfDFR6u8HCFhys8XOHhCg9XeLjCwxUervBwhYcrPFzh4QoPV3i4wsMVHq7wcIWHKzxc4eEKD1d4uMLDFR6u8HCFhys8XOHhCg9XeLjCwxUervBwhYcrJ7c7ud3J7U5ud3K7k9ud3O7kdie3O7ndye1Obndyu5Pbndzu5HYntzu53bmeO9dz53ruXM/bw23v6qvH1z/OPuVno08pt9RPGV3aLf3+grhl3l9Qt1z3F9xu+fALUm6p9xfYLf3+grhl3l9Qt1z3F2zKuu+t7nur+97qvre6763ue6v73uq+t7rvre57W/e9rfve1n1v6763dd/buu9t3fe27ntb972t+972fW/7vrd939u+723f97bve9v3ve373vZ9b5v31oTu/QVt6KbU+wvsln5/Qdwy7y+oW677C3hvjenOLxC5pd5fYLf0+wvilnl/Qd1y3V9w35ve96b3vel9b3rfm973pve96X1vet+b3vem973ZfW9235vd92b3vdl9b3bfm933Zve92X1vdt+b3/fm9735fW9+35vf9+b3vfl9b37fm9/35ve93VkSd5bEnSVxZ0ncWRJ3lsSdJXFnSdxZEneWxJ0lcWdJ3FkSd5bEnSVxZ0ncWRJ3lsSdJXFnSdxZEneWxJ0lcWdJ3FkSd5bEnSVxZ0ncWRJ3lsSdJXFnSdxZEneWxJ0lcWdJ3FkSd5bEnSVxZ0ncWRJ3lsSdJXFnSdxZEneWxJ0lcWdJ3FkSd5bknSV5Z0neWZJ3luSdJXlnSd5ZkneW5J0leWdJ3lmSd5bknSV5Z0neWZJ3luSdJXlnSd5ZkneW5J0leWdJ3lmSd5bknSV5Z0neWZJ3luSdJXlnSd5ZkneW5J0leWdJ3lmSd5bknSV5Z0neWZJ3luSdJXlnSd5ZkneW5J0leWdJ3lmSd5bknSV5Z0neWZJ3luSdJXlnSd5ZkneW5J0leWdJA7+vnwV3uSl7lpxSbqm3tFv6LeOWecu65e2Wt1vdbnW71e1Wt1vdbnW71e1Wt1vdbnW7rdtt3W7rdlu327rd1u22brd1u63bbd1u+3bbt9u+3fbttm+3fbvt223fbvt223RrCjil3FJvabf0W8Yt85Z1y3XL201uN7nd5HbrWSLVZXfbXcYt85Z1y3XLTdmz5JRyS72l3fJ209tNbze93fTt9tff/fK/fv+XP/7+H/70h3//5W/+6+v//ef//PM//scf//XP5//9j//n3+Yr//CXP/7pT3/8l7//t7/86z/+4Z/+8y9/+Ps//es/fr72y/P5P58/l7/d9ru9/u53v3z+ZP5279997cK/+/pPhV+g/jvdn/9J7/9UvzP9u7/+9a9/99f/Fw==","file_map":{"17":{"source":"use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\npub(crate) global PLO: Field = 53438638232309528389504892708671455233;\npub(crate) global PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 128 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low = (x as u128) as Field;\n    let high = (x - low) / TWO_POW_128;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    // Safety: borrow is enforced to be boolean due to its type.\n    // if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n    // if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        // Safety: decomposition is properly checked below\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            // Safety: already unconstrained\n            unsafe { field_less_than(b, a) },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unsafe in unconstrained\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        // Safety: Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n\n    #[test]\n    fn check_decompose_edge_cases() {\n        assert_eq(decompose(0), (0, 0));\n        assert_eq(decompose(TWO_POW_128 - 1), (TWO_POW_128 - 1, 0));\n        assert_eq(decompose(TWO_POW_128 + 1), (1, 1));\n        assert_eq(decompose(TWO_POW_128 * 2), (0, 2));\n        assert_eq(decompose(TWO_POW_128 * 2 + 0x1234567890), (0x1234567890, 2));\n    }\n\n    #[test]\n    fn check_decompose_large_values() {\n        let large_field = 0xffffffffffffffff;\n        let (lo, hi) = decompose(large_field);\n        assert_eq(large_field, lo + TWO_POW_128 * hi);\n\n        let large_value = large_field - TWO_POW_128;\n        let (lo2, hi2) = decompose(large_value);\n        assert_eq(large_value, lo2 + TWO_POW_128 * hi2);\n    }\n\n    #[test]\n    fn check_lt_comprehensive() {\n        assert(lt(0, 1));\n        assert(!lt(1, 0));\n        assert(!lt(0, 0));\n        assert(!lt(42, 42));\n\n        assert(lt(TWO_POW_128 - 1, TWO_POW_128));\n        assert(!lt(TWO_POW_128, TWO_POW_128 - 1));\n    }\n}\n","path":"std/field/bn254.nr"},"18":{"source":"pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        __assert_max_bit_size(self, BIT_SIZE);\n    }\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting array will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = __to_le_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting array will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = __to_be_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_le_radix(self, radix)\n    }\n\n    fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_be_radix(self, radix)\n    }\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(apply_range_constraint)]\nfn __assert_max_bit_size(value: Field, bit_size: u32) {}\n\n// `_radix` must be less than 256\n#[builtin(to_le_radix)]\nfn __to_le_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n// `_radix` must be less than 256\n#[builtin(to_be_radix)]\nfn __to_be_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n/// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n/// This array will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting array will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_le_bits)]\nfn __to_le_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n/// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n/// This array will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting array will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_be_bits)]\nfn __to_be_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime, static_assert};\n    use super::{\n        field_less_than, modulus_be_bits, modulus_be_bytes, modulus_le_bits, modulus_le_bytes,\n    };\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(\"radix must be greater than 1\");\n        }\n    }\n\n    // Updated test to account for Brillig restriction that radix must be greater than 2\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_brillig_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 1;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(\"radix must be greater than 1\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(\"radix must be less than or equal to 256\")\n        }\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 16 limbs\")]\n    unconstrained fn not_enough_limbs_brillig() {\n        let _: [u8; 16] = 0x100000000000000000000000000000000.to_le_bytes();\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 16 limbs\")]\n    fn not_enough_limbs() {\n        let _: [u8; 16] = 0x100000000000000000000000000000000.to_le_bytes();\n    }\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n\n    #[test]\n    unconstrained fn test_large_field_values_unconstrained() {\n        let large_field = 0xffffffffffffffff;\n\n        let bits: [u1; 64] = large_field.to_le_bits();\n        assert_eq(bits[0], 1);\n\n        let bytes: [u8; 8] = large_field.to_le_bytes();\n        assert_eq(Field::from_le_bytes::<8>(bytes), large_field);\n\n        let radix_bytes: [u8; 8] = large_field.to_le_radix(256);\n        assert_eq(Field::from_le_bytes::<8>(radix_bytes), large_field);\n    }\n\n    #[test]\n    fn test_large_field_values() {\n        let large_val = 0xffffffffffffffff;\n\n        let bits: [u1; 64] = large_val.to_le_bits();\n        assert_eq(bits[0], 1);\n\n        let bytes: [u8; 8] = large_val.to_le_bytes();\n        assert_eq(Field::from_le_bytes::<8>(bytes), large_val);\n\n        let radix_bytes: [u8; 8] = large_val.to_le_radix(256);\n        assert_eq(Field::from_le_bytes::<8>(radix_bytes), large_val);\n    }\n\n    #[test]\n    fn test_decomposition_edge_cases() {\n        let zero_bits: [u1; 8] = 0.to_le_bits();\n        assert_eq(zero_bits, [0; 8]);\n\n        let zero_bytes: [u8; 8] = 0.to_le_bytes();\n        assert_eq(zero_bytes, [0; 8]);\n\n        let one_bits: [u1; 8] = 1.to_le_bits();\n        let expected: [u1; 8] = [1, 0, 0, 0, 0, 0, 0, 0];\n        assert_eq(one_bits, expected);\n\n        let pow2_bits: [u1; 8] = 4.to_le_bits();\n        let expected: [u1; 8] = [0, 0, 1, 0, 0, 0, 0, 0];\n        assert_eq(pow2_bits, expected);\n    }\n\n    #[test]\n    fn test_pow_32() {\n        assert_eq(2.pow_32(3), 8);\n        assert_eq(3.pow_32(2), 9);\n        assert_eq(5.pow_32(0), 1);\n        assert_eq(7.pow_32(1), 7);\n\n        assert_eq(2.pow_32(10), 1024);\n\n        assert_eq(0.pow_32(5), 0);\n        assert_eq(0.pow_32(0), 1);\n\n        assert_eq(1.pow_32(100), 1);\n    }\n\n    #[test]\n    fn test_sgn0() {\n        assert_eq(0.sgn0(), 0);\n        assert_eq(2.sgn0(), 0);\n        assert_eq(4.sgn0(), 0);\n        assert_eq(100.sgn0(), 0);\n\n        assert_eq(1.sgn0(), 1);\n        assert_eq(3.sgn0(), 1);\n        assert_eq(5.sgn0(), 1);\n        assert_eq(101.sgn0(), 1);\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 8 limbs\")]\n    fn test_bit_decomposition_overflow() {\n        // 8 bits can't represent large field values\n        let large_val = 0x1000000000000000;\n        let _: [u1; 8] = large_val.to_le_bits();\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 4 limbs\")]\n    fn test_byte_decomposition_overflow() {\n        // 4 bytes can't represent large field values\n        let large_val = 0x1000000000000000;\n        let _: [u8; 4] = large_val.to_le_bytes();\n    }\n\n    #[test]\n    fn test_to_from_be_bytes_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this byte produces the expected 32 BE bytes for (modulus - 1)\n            let mut p_minus_1_bytes: [u8; 32] = modulus_be_bytes().as_array();\n            assert(p_minus_1_bytes[32 - 1] > 0);\n            p_minus_1_bytes[32 - 1] -= 1;\n\n            let p_minus_1 = Field::from_be_bytes::<32>(p_minus_1_bytes);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 32 BE bytes produces the same bytes\n            let p_minus_1_converted_bytes: [u8; 32] = p_minus_1.to_be_bytes();\n            assert_eq(p_minus_1_converted_bytes, p_minus_1_bytes);\n\n            // checking that incrementing this byte produces 32 BE bytes for (modulus + 1)\n            let mut p_plus_1_bytes: [u8; 32] = modulus_be_bytes().as_array();\n            assert(p_plus_1_bytes[32 - 1] < 255);\n            p_plus_1_bytes[32 - 1] += 1;\n\n            let p_plus_1 = Field::from_be_bytes::<32>(p_plus_1_bytes);\n            assert_eq(p_plus_1, 1);\n\n            // checking that converting p_plus_1 to 32 BE bytes produces the same\n            // byte set to 1 as p_plus_1_bytes and otherwise zeroes\n            let mut p_plus_1_converted_bytes: [u8; 32] = p_plus_1.to_be_bytes();\n            assert_eq(p_plus_1_converted_bytes[32 - 1], 1);\n            p_plus_1_converted_bytes[32 - 1] = 0;\n            assert_eq(p_plus_1_converted_bytes, [0; 32]);\n\n            // checking that Field::from_be_bytes::<32> on the Field modulus produces 0\n            assert_eq(modulus_be_bytes().len(), 32);\n            let p = Field::from_be_bytes::<32>(modulus_be_bytes().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 32 BE bytes produces 32 zeroes\n            let p_bytes: [u8; 32] = 0.to_be_bytes();\n            assert_eq(p_bytes, [0; 32]);\n        }\n    }\n\n    #[test]\n    fn test_to_from_le_bytes_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this byte produces the expected 32 LE bytes for (modulus - 1)\n            let mut p_minus_1_bytes: [u8; 32] = modulus_le_bytes().as_array();\n            assert(p_minus_1_bytes[0] > 0);\n            p_minus_1_bytes[0] -= 1;\n\n            let p_minus_1 = Field::from_le_bytes::<32>(p_minus_1_bytes);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 32 BE bytes produces the same bytes\n            let p_minus_1_converted_bytes: [u8; 32] = p_minus_1.to_le_bytes();\n            assert_eq(p_minus_1_converted_bytes, p_minus_1_bytes);\n\n            // checking that incrementing this byte produces 32 LE bytes for (modulus + 1)\n            let mut p_plus_1_bytes: [u8; 32] = modulus_le_bytes().as_array();\n            assert(p_plus_1_bytes[0] < 255);\n            p_plus_1_bytes[0] += 1;\n\n            let p_plus_1 = Field::from_le_bytes::<32>(p_plus_1_bytes);\n            assert_eq(p_plus_1, 1);\n\n            // checking that converting p_plus_1 to 32 LE bytes produces the same\n            // byte set to 1 as p_plus_1_bytes and otherwise zeroes\n            let mut p_plus_1_converted_bytes: [u8; 32] = p_plus_1.to_le_bytes();\n            assert_eq(p_plus_1_converted_bytes[0], 1);\n            p_plus_1_converted_bytes[0] = 0;\n            assert_eq(p_plus_1_converted_bytes, [0; 32]);\n\n            // checking that Field::from_le_bytes::<32> on the Field modulus produces 0\n            assert_eq(modulus_le_bytes().len(), 32);\n            let p = Field::from_le_bytes::<32>(modulus_le_bytes().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 32 LE bytes produces 32 zeroes\n            let p_bytes: [u8; 32] = 0.to_le_bytes();\n            assert_eq(p_bytes, [0; 32]);\n        }\n    }\n\n    /// Convert a little endian bit array to a field element.\n    /// If the provided bit array overflows the field modulus then the Field will silently wrap around.\n    fn from_le_bits<let N: u32>(bits: [u1; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bits().len(),\n            \"N must be less than or equal to modulus_le_bits().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bits[i] as Field) * v;\n            v = v * 2;\n        }\n        result\n    }\n\n    /// Convert a big endian bit array to a field element.\n    /// If the provided bit array overflows the field modulus then the Field will silently wrap around.\n    fn from_be_bits<let N: u32>(bits: [u1; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bits[N - 1 - i] as Field) * v;\n            v = v * 2;\n        }\n        result\n    }\n\n    #[test]\n    fn test_to_from_be_bits_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this bit produces the expected 254 BE bits for (modulus - 1)\n            let mut p_minus_1_bits: [u1; 254] = modulus_be_bits().as_array();\n            assert(p_minus_1_bits[254 - 1] > 0);\n            p_minus_1_bits[254 - 1] -= 1;\n\n            let p_minus_1 = from_be_bits::<254>(p_minus_1_bits);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 254 BE bits produces the same bits\n            let p_minus_1_converted_bits: [u1; 254] = p_minus_1.to_be_bits();\n            assert_eq(p_minus_1_converted_bits, p_minus_1_bits);\n\n            // checking that incrementing this bit produces 254 BE bits for (modulus + 4)\n            let mut p_plus_4_bits: [u1; 254] = modulus_be_bits().as_array();\n            assert(p_plus_4_bits[254 - 3] < 1);\n            p_plus_4_bits[254 - 3] += 1;\n\n            let p_plus_4 = from_be_bits::<254>(p_plus_4_bits);\n            assert_eq(p_plus_4, 4);\n\n            // checking that converting p_plus_4 to 254 BE bits produces the same\n            // bit set to 1 as p_plus_4_bits and otherwise zeroes\n            let mut p_plus_4_converted_bits: [u1; 254] = p_plus_4.to_be_bits();\n            assert_eq(p_plus_4_converted_bits[254 - 3], 1);\n            p_plus_4_converted_bits[254 - 3] = 0;\n            assert_eq(p_plus_4_converted_bits, [0; 254]);\n\n            // checking that Field::from_be_bits::<254> on the Field modulus produces 0\n            assert_eq(modulus_be_bits().len(), 254);\n            let p = from_be_bits::<254>(modulus_be_bits().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 254 BE bytes produces 254 zeroes\n            let p_bits: [u1; 254] = 0.to_be_bits();\n            assert_eq(p_bits, [0; 254]);\n        }\n    }\n\n    #[test]\n    fn test_to_from_le_bits_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this bit produces the expected 254 LE bits for (modulus - 1)\n            let mut p_minus_1_bits: [u1; 254] = modulus_le_bits().as_array();\n            assert(p_minus_1_bits[0] > 0);\n            p_minus_1_bits[0] -= 1;\n\n            let p_minus_1 = from_le_bits::<254>(p_minus_1_bits);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 254 BE bits produces the same bits\n            let p_minus_1_converted_bits: [u1; 254] = p_minus_1.to_le_bits();\n            assert_eq(p_minus_1_converted_bits, p_minus_1_bits);\n\n            // checking that incrementing this bit produces 254 LE bits for (modulus + 4)\n            let mut p_plus_4_bits: [u1; 254] = modulus_le_bits().as_array();\n            assert(p_plus_4_bits[2] < 1);\n            p_plus_4_bits[2] += 1;\n\n            let p_plus_4 = from_le_bits::<254>(p_plus_4_bits);\n            assert_eq(p_plus_4, 4);\n\n            // checking that converting p_plus_4 to 254 LE bits produces the same\n            // bit set to 1 as p_plus_4_bits and otherwise zeroes\n            let mut p_plus_4_converted_bits: [u1; 254] = p_plus_4.to_le_bits();\n            assert_eq(p_plus_4_converted_bits[2], 1);\n            p_plus_4_converted_bits[2] = 0;\n            assert_eq(p_plus_4_converted_bits, [0; 254]);\n\n            // checking that Field::from_le_bits::<254> on the Field modulus produces 0\n            assert_eq(modulus_le_bits().len(), 254);\n            let p = from_le_bits::<254>(modulus_le_bits().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 254 LE bytes produces 254 zeroes\n            let p_bits: [u1; 254] = 0.to_le_bits();\n            assert_eq(p_bits, [0; 254]);\n        }\n    }\n}\n","path":"std/field/mod.nr"},"19":{"source":"// Exposed only for usage in `std::meta`\npub(crate) mod poseidon2;\n\nuse crate::default::Default;\nuse crate::embedded_curve_ops::{\n    EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_array_return,\n};\nuse crate::meta::derive_via;\n\n#[foreign(sha256_compression)]\n// docs:start:sha256_compression\npub fn sha256_compression(input: [u32; 16], state: [u32; 8]) -> [u32; 8] {}\n// docs:end:sha256_compression\n\n#[foreign(keccakf1600)]\n// docs:start:keccakf1600\npub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {}\n// docs:end:keccakf1600\n\npub mod keccak {\n    #[deprecated(\"This function has been moved to std::hash::keccakf1600\")]\n    pub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {\n        super::keccakf1600(input)\n    }\n}\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{\n    if crate::runtime::is_unconstrained() {\n        // Temporary measure while Barretenberg is main proving system.\n        // Please open an issue if you're working on another proving system and running into problems due to this.\n        crate::static_assert(\n            N <= 1024,\n            \"Barretenberg cannot prove blake3 hashes with inputs larger than 1024 bytes\",\n        );\n    }\n    __blake3(input)\n}\n\n#[foreign(blake3)]\nfn __blake3<let N: u32>(input: [u8; N]) -> [u8; 32] {}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\n#[inline_always]\npub fn pedersen_commitment_with_separator<let N: u32>(\n    input: [Field; N],\n    separator: u32,\n) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        // we use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        points[i] = from_field_unsafe(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    multi_scalar_mul(generators, points)\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[no_predicates]\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let mut scalars: [EmbeddedCurveScalar; N + 1] = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N + 1];\n    let mut generators: [EmbeddedCurvePoint; N + 1] =\n        [EmbeddedCurvePoint::point_at_infinity(); N + 1];\n    let domain_generators: [EmbeddedCurvePoint; N] =\n        derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n\n    for i in 0..N {\n        scalars[i] = from_field_unsafe(input[i]);\n        generators[i] = domain_generators[i];\n    }\n    scalars[N] = EmbeddedCurveScalar { lo: N as Field, hi: 0 as Field };\n\n    let length_generator: [EmbeddedCurvePoint; 1] =\n        derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    generators[N] = length_generator[0];\n    multi_scalar_mul_array_return(generators, scalars, true)[0].x\n}\n\n#[field(bn254)]\n#[inline_always]\npub fn derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    // TODO(https://github.com/noir-lang/noir/issues/5672): Add back assert_constant on starting_index\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {}\n\n#[field(bn254)]\n// Decompose the input 'bn254 scalar' into two 128 bits limbs.\n// It is called 'unsafe' because it does not assert the limbs are 128 bits\n// Assuming the limbs are 128 bits:\n// Assert the decomposition does not overflow the field size.\nfn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {\n    // Safety: xlo and xhi decomposition is checked below\n    let (xlo, xhi) = unsafe { crate::field::bn254::decompose_hint(scalar) };\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);\n    // Check that the decomposition does not overflow the field size\n    let (a, b) = if xhi == crate::field::bn254::PHI {\n        (xlo, crate::field::bn254::PLO)\n    } else {\n        (xhi, crate::field::bn254::PHI)\n    };\n    crate::field::bn254::assert_lt(a, b);\n\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n\npub fn poseidon2_permutation<let N: u32>(input: [Field; N], state_len: u32) -> [Field; N] {\n    assert_eq(input.len(), state_len);\n    poseidon2_permutation_internal(input)\n}\n\n#[foreign(poseidon2_permutation)]\nfn poseidon2_permutation_internal<let N: u32>(input: [Field; N]) -> [Field; N] {}\n\n// Generic hashing support.\n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\n#[derive_via(derive_hash)]\npub trait Hash {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher;\n}\n\n// docs:start:derive_hash\ncomptime fn derive_hash(s: TypeDefinition) -> Quoted {\n    let name = quote { $crate::hash::Hash };\n    let signature = quote { fn hash<H>(_self: Self, _state: &mut H) where H: $crate::hash::Hasher };\n    let for_each_field = |name| quote { _self.$name.hash(_state); };\n    crate::meta::make_trait_impl(\n        s,\n        name,\n        signature,\n        for_each_field,\n        quote {},\n        |fields| fields,\n    )\n}\n// docs:end:derive_hash\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\npub trait Hasher {\n    fn finish(self) -> Field;\n\n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\npub trait BuildHasher {\n    type H: Hasher;\n\n    fn build_hasher(self) -> H;\n}\n\npub struct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    type H = H;\n\n    fn build_hasher(_self: Self) -> H {\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn default() -> Self {\n        BuildHasherDefault {}\n    }\n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u1 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u128 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u8 as Field);\n    }\n}\n\nimpl Hash for i16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u16 as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u32 as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u64 as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H)\n    where\n        H: Hasher,\n    {}\n}\n\nimpl<T, let N: u32> Hash for [T; N]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B)\nwhere\n    A: Hash,\n    B: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n    E: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n// Some test vectors for Pedersen hash and Pedersen Commitment.\n// They have been generated using the same functions so the tests are for now useless\n// but they will be useful when we switch to Noir implementation.\n#[test]\nfn assert_pedersen() {\n    assert_eq(\n        pedersen_hash_with_separator([1], 1),\n        0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1], 1),\n        EmbeddedCurvePoint {\n            x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,\n            y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,\n            is_infinite: false,\n        },\n    );\n\n    assert_eq(\n        pedersen_hash_with_separator([1, 2], 2),\n        0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2], 2),\n        EmbeddedCurvePoint {\n            x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,\n            y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3], 3),\n        0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3], 3),\n        EmbeddedCurvePoint {\n            x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,\n            y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4], 4),\n        0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4], 4),\n        EmbeddedCurvePoint {\n            x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,\n            y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5),\n        0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5),\n        EmbeddedCurvePoint {\n            x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,\n            y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6),\n        0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6),\n        EmbeddedCurvePoint {\n            x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,\n            y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        EmbeddedCurvePoint {\n            x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,\n            y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        EmbeddedCurvePoint {\n            x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,\n            y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        EmbeddedCurvePoint {\n            x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,\n            y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        EmbeddedCurvePoint {\n            x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,\n            y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,\n            is_infinite: false,\n        },\n    );\n}\n","path":"std/hash/mod.nr"},"51":{"source":"use assist::{DECK_SIZE, fisher_yates_shuffle, get_cards, merkle_root};\n\n/// --- ESTABLISH AUTHENTICITY OF SHUFFLED DECK ---\n/// use the random seed to shuffle the deck\n/// find the merkle root the shuffled deck and compare against the input onchain commitment\n///\n/// # Arguments\n/// * `seed` - The random seed value.\n/// * `root_commitment` - The onchain commitment of the merkle root of the shuffled deck.\n/// * `cards` - The first 15 cards of the shufflled deck being shared with the contract.\nfn main(seed: Field, root_commitment: pub Field, cards: [Field; 15]) {\n    // authenticity check of shuffled deck\n    let shuffled_deck: [Field; DECK_SIZE] = fisher_yates_shuffle(seed);\n    let deck_merkle_root: Field = merkle_root(shuffled_deck, seed);\n    assert(deck_merkle_root == root_commitment, \"Deck merkle root does not match commitment\");\n\n    let selected_cards = get_cards(shuffled_deck);\n    for i in 0..cards.len() {\n        assert(cards[i] == selected_cards[i], \"Mismatch in the allocated cards\");\n    }\n}\n","path":"/home/ally/DevEnv/pvtDock/KH/poker-solana/backend/src/services/circuitry/shuffle/src/main.nr"},"52":{"source":"use poseidon::poseidon2::Poseidon2;\nuse std::field::bn254::assert_lt;\n\n/// Number of cards in a standard deck.\npub global DECK_SIZE: u32 = 52;\n\n/// Number of cards to deal for gameplay (5 players * 2 cards + 5 community cards = 15).\npub global CARDS_TO_DEAL: u32 = 15;\n\n// Domain separators prevent cross-protocol hash collisions.\npub global HASH_DOMAIN_SEPARATOR_SEED: Field = 1;\npub global HASH_DOMAIN_SEPARATOR_DECK: Field = 2;\npub global HASH_DOMAIN_SEPARATOR_CARD: Field = 3;\n\n/// Domain separator for Fisher-Yates RNG state transitions.\npub global HASH_DOMAIN_SEPARATOR_RNG: Field = 4;\npub global PADDING_NONCE: Field = 5;\n\n/// Performs a deterministic Fisher-Yates shuffle on a 52-card deck.\n///\n/// # Arguments\n/// * `seed` - Random seed from on-chain randomness source.\n///\n/// # Returns\n/// A shuffled deck represented as an array of Field elements (0-51).\n///\n/// # Security Properties\n/// - Deterministic: Same seed always produces the same shuffle.\n/// - Uniform: Each permutation is equally likely given a uniformly random seed.\n/// - Verifiable: The shuffle can be independently verified with the seed.\n#[export]\npub fn fisher_yates_shuffle(seed: Field) -> [Field; DECK_SIZE] {\n    // Initialize the deck as 0-51 indices\n    let mut deck = [0; DECK_SIZE];\n    for i in 0..DECK_SIZE {\n        deck[i] = i as Field;\n    }\n\n    // Initialize the RNG state with the random seed using domain separator\n    let mut rng_state = Poseidon2::hash([HASH_DOMAIN_SEPARATOR_RNG, seed], 2);\n\n    // Perform the Fisher-Yates shuffle\n    // Iterate from the last element down to the second element\n    for i in 0..(DECK_SIZE - 1) {\n        let idx = (DECK_SIZE - 1) - i;\n\n        // Generate random hash with domain-separated RNG state update\n        rng_state = Poseidon2::hash([HASH_DOMAIN_SEPARATOR_RNG, rng_state, idx as Field], 3);\n\n        // Calculate the swap index unconstrained\n        let range = (idx + 1) as Field;\n        // Safety: constraints enabled by proceeding assertions\n        let (quotient, remainder) = unsafe { divide_hint(rng_state, range) };\n\n        // Constrain the division result: rng_state = quotient * range + remainder\n        assert(rng_state == quotient * range + remainder);\n        // Ensure remainder is in valid range [0, range)\n        assert_lt(remainder, range);\n\n        let swap_idx = remainder as u32;\n\n        // Perform the swap\n        if swap_idx != idx {\n            let temp = deck[idx];\n            deck[idx] = deck[swap_idx];\n            deck[swap_idx] = temp;\n        }\n    }\n\n    deck\n}\n\n/// Unconstrained hint for field division.\n/// Computes (quotient, remainder) such that numerator = quotient * denominator + remainder.\nunconstrained fn divide_hint(numerator: Field, denominator: Field) -> (Field, Field) {\n    // NOTE: assuming denominator is small enough to fit in u32 (as is the case for a DECK_SIZE of 52)\n    let den_u64 = denominator as u64;\n    // Minimal check to avoid division by zero\n    assert(den_u64 != 0);\n    // Ensure denominator fits in u32 to guarantee 'remainder * 256' fits in u64\n    assert(den_u64 <= 4294967295);\n\n    let bytes: [u8; 32] = numerator.to_be_bytes();\n    let mut remainder: u64 = 0;\n    let mut quotient: Field = 0;\n\n    for i in 0..32 {\n        let b = bytes[i] as u64;\n        let val = remainder * 256 + b;\n        let q_digit = val / den_u64;\n        let r_digit = val % den_u64;\n\n        quotient = quotient * 256 + (q_digit as Field);\n        remainder = r_digit;\n    }\n    (quotient, remainder as Field)\n}\n\n/// Computes the Merkle root of a shuffled deck.\n///\n/// # Arguments\n/// * `deck` - The shuffled deck array.\n/// * `seed` - The shuffle seed (used to derive salt for binding).\n///\n/// # Returns\n/// The Merkle root hash of the deck.\n///\n/// # Implementation Notes\n/// - Uses a 64-leaf tree (52 cards + 12 padding leaves).\n/// - Each card is hashed with its position and a seed-derived salt.\n#[export]\npub fn merkle_root(deck: [Field; DECK_SIZE], seed: Field) -> Field {\n    // Generate salt for binding cards to this specific shuffle\n    let salt = derive_salt(seed);\n\n    // Hash all cards directly into buffer\n    let mut buffer: [Field; 64] = [0; 64];\n\n    for i in 0..DECK_SIZE {\n        buffer[i] = hash_card_in_deck(deck[i], i as Field, salt);\n    }\n\n    // Pad buffer with a fixed value to reach power of 2 tree size\n    let padding = Poseidon2::hash([HASH_DOMAIN_SEPARATOR_DECK, PADDING_NONCE], 2);\n    for i in DECK_SIZE..64 {\n        buffer[i] = padding;\n    }\n\n    // Build tree bottom-up, reusing buffer space\n    // After each level, results are stored in the first half of the buffer\n    let mut size = 64;\n    for _ in 0..6 {\n        let next_size = size / 2;\n        for i in 0..next_size {\n            buffer[i] = merkle_a_pair(buffer[i * 2], buffer[i * 2 + 1]);\n        }\n        size = next_size;\n    }\n\n    buffer[0]\n}\n\n/// Derives a salt from the shuffle seed for card hashing.\npub fn derive_salt(seed: Field) -> Field {\n    Poseidon2::hash([seed, HASH_DOMAIN_SEPARATOR_CARD], 2)\n}\n\n/// Hashes a card at a specific position with salt.\n/// The position ensures uniqueness even for duplicate card values.\npub fn hash_card_in_deck(card: Field, position: Field, salt: Field) -> Field {\n    Poseidon2::hash([HASH_DOMAIN_SEPARATOR_CARD, card, position, salt], 4)\n}\n\n/// Hashes two child nodes to produce a parent node in the Merkle tree.\npub fn merkle_a_pair(left: Field, right: Field) -> Field {\n    Poseidon2::hash([left, right], 2)\n}\n\n/// Extracts the first CARDS_TO_DEAL cards from the shuffled deck.\n///\n/// # Arguments\n/// * `deck` - The shuffled deck array.\n///\n/// # Returns\n/// An array of the first 15 cards for gameplay.\n#[export]\npub fn get_cards(deck: [Field; DECK_SIZE]) -> [Field; CARDS_TO_DEAL] {\n    let mut cards = [0; CARDS_TO_DEAL];\n    for i in 0..CARDS_TO_DEAL {\n        cards[i] = deck[i];\n    }\n    cards\n}\n\n/// Commitments of card allocations to respective players\n///\n/// # Arguments\n/// * `cards` - The cards array.\n/// * `players` - The players array.\n/// * `player_status` - The player status array - if player is not in the game, commitment is 0\n///\n/// # Returns\n/// An array of commitments for the cards.\n#[export]\npub fn calculate_commitment(\n    cards: [Field; 10],\n    players: [Field; 5],\n    player_status: [bool; 5],\n) -> [Field; 10] {\n    let mut commitments: [Field; 10] = [0; 10];\n    let mut k = 0;\n\n    for i in 0..cards.len() {\n        let player: Field = players[k];\n\n        commitments[i] = if player_status[k] {\n            Poseidon2::hash([cards[i], player], 2)\n        } else {\n            0\n        };\n\n        if (i % 2 != 0) {\n            k += 1;\n        }\n    }\n\n    commitments\n}\n\n/// Commitment of community cards\n///\n/// # Arguments\n/// * `cards` - The cards array.\n///\n/// # Returns\n/// The commitment for the community cards.\n#[export]\npub fn calculate_community_commitment(cards: [Field; 5]) -> Field {\n    Poseidon2::hash([cards[0], cards[1], cards[2], cards[3], cards[4]], 5)\n}\n\n// =============================================================================\n// Test Module\n// =============================================================================\n\nmod tests {\n    use super::{\n        calculate_commitment, calculate_community_commitment, CARDS_TO_DEAL, DECK_SIZE, derive_salt,\n        fisher_yates_shuffle, get_cards, hash_card_in_deck, merkle_a_pair, merkle_root,\n    };\n    use poseidon::poseidon2::Poseidon2;\n\n    // -------------------------------------------------------------------------\n    // Fisher-Yates Shuffle Tests\n    // -------------------------------------------------------------------------\n\n    #[test]\n    fn test_shuffle_produces_valid_permutation() {\n        // A valid permutation contains each card exactly once\n        let seed: Field = 12345;\n        let deck = fisher_yates_shuffle(seed);\n\n        // Check that all cards 0-51 appear exactly once\n        let mut card_count: [u32; DECK_SIZE] = [0; DECK_SIZE];\n        for i in 0..DECK_SIZE {\n            let card_idx = deck[i] as u32;\n            assert(card_idx < DECK_SIZE, \"Card index out of bounds\");\n            card_count[card_idx] += 1;\n        }\n\n        for i in 0..DECK_SIZE {\n            assert(card_count[i] == 1, \"Each card must appear exactly once\");\n        }\n    }\n\n    #[test]\n    fn test_shuffle_is_deterministic() {\n        // Same seed must produce the same shuffle\n        let seed: Field = 0xabcdef123456;\n        let deck1 = fisher_yates_shuffle(seed);\n        let deck2 = fisher_yates_shuffle(seed);\n\n        for i in 0..DECK_SIZE {\n            assert(deck1[i] == deck2[i], \"Shuffle must be deterministic\");\n        }\n    }\n\n    #[test]\n    fn test_shuffle_different_seeds_produce_different_decks() {\n        let deck1 = fisher_yates_shuffle(1);\n        let deck2 = fisher_yates_shuffle(2);\n\n        // At least one card should be in a different position\n        let mut has_difference = false;\n        for i in 0..DECK_SIZE {\n            if deck1[i] != deck2[i] {\n                has_difference = true;\n            }\n        }\n        assert(has_difference, \"Different seeds should produce different shuffles\");\n    }\n\n    #[test]\n    fn test_shuffle_with_zero_seed() {\n        // Zero seed should still produce a valid permutation\n        let deck = fisher_yates_shuffle(0);\n\n        let mut card_count: [u32; DECK_SIZE] = [0; DECK_SIZE];\n        for i in 0..DECK_SIZE {\n            let card_idx = deck[i] as u32;\n            card_count[card_idx] += 1;\n        }\n\n        for i in 0..DECK_SIZE {\n            assert(card_count[i] == 1, \"Each card must appear exactly once\");\n        }\n    }\n\n    // -------------------------------------------------------------------------\n    // Merkle Root Tests\n    // -------------------------------------------------------------------------\n\n    #[test]\n    fn test_merkle_root_is_deterministic() {\n        let seed: Field = 42;\n        let deck = fisher_yates_shuffle(seed);\n\n        let root1 = merkle_root(deck, seed);\n        let root2 = merkle_root(deck, seed);\n\n        assert(root1 == root2, \"Merkle root must be deterministic\");\n    }\n\n    #[test]\n    fn test_merkle_root_different_decks_produce_different_roots() {\n        let deck1 = fisher_yates_shuffle(100);\n        let deck2 = fisher_yates_shuffle(200);\n\n        let root1 = merkle_root(deck1, 100);\n        let root2 = merkle_root(deck2, 200);\n\n        assert(root1 != root2, \"Different decks should produce different roots\");\n    }\n\n    #[test]\n    fn test_merkle_root_same_deck_different_seed_produces_different_root() {\n        // The seed affects the salt, so same deck with different seeds = different roots\n        let deck = fisher_yates_shuffle(123);\n\n        let root1 = merkle_root(deck, 123);\n        let root2 = merkle_root(deck, 456);\n\n        assert(root1 != root2, \"Same deck with different seeds should produce different roots\");\n    }\n\n    // -------------------------------------------------------------------------\n    // Helper Function Tests\n    // -------------------------------------------------------------------------\n\n    #[test]\n    fn test_derive_salt_is_deterministic() {\n        let seed: Field = 999;\n        let salt1 = derive_salt(seed);\n        let salt2 = derive_salt(seed);\n\n        assert(salt1 == salt2, \"derive_salt must be deterministic\");\n    }\n\n    #[test]\n    fn test_derive_salt_different_seeds_produce_different_salts() {\n        let salt1 = derive_salt(1);\n        let salt2 = derive_salt(2);\n\n        assert(salt1 != salt2, \"Different seeds should produce different salts\");\n    }\n\n    #[test]\n    fn test_hash_card_is_deterministic() {\n        let card: Field = 10;\n        let position: Field = 5;\n        let salt: Field = 12345;\n\n        let hash1 = hash_card_in_deck(card, position, salt);\n        let hash2 = hash_card_in_deck(card, position, salt);\n\n        assert(hash1 == hash2, \"hash_card_in_deck must be deterministic\");\n    }\n\n    #[test]\n    fn test_hash_card_position_affects_hash() {\n        let card: Field = 10;\n        let salt: Field = 12345;\n\n        let hash1 = hash_card_in_deck(card, 0, salt);\n        let hash2 = hash_card_in_deck(card, 1, salt);\n\n        assert(hash1 != hash2, \"Different positions should produce different hashes\");\n    }\n\n    #[test]\n    fn test_merkle_pair_is_deterministic() {\n        let left: Field = 111;\n        let right: Field = 222;\n\n        let hash1 = merkle_a_pair(left, right);\n        let hash2 = merkle_a_pair(left, right);\n\n        assert(hash1 == hash2, \"merkle_a_pair must be deterministic\");\n    }\n\n    #[test]\n    fn test_merkle_pair_order_matters() {\n        let a: Field = 111;\n        let b: Field = 222;\n\n        let hash1 = merkle_a_pair(a, b);\n        let hash2 = merkle_a_pair(b, a);\n\n        assert(hash1 != hash2, \"merkle_a_pair should be order-sensitive\");\n    }\n\n    // -------------------------------------------------------------------------\n    // Card Selection Tests\n    // -------------------------------------------------------------------------\n\n    #[test]\n    fn test_get_cards_extracts_first_fifteen() {\n        let deck = fisher_yates_shuffle(777);\n        let cards = get_cards(deck);\n\n        for i in 0..CARDS_TO_DEAL {\n            assert(cards[i] == deck[i], \"get_cards should extract cards in order\");\n        }\n    }\n\n    #[test]\n    fn test_get_cards_returns_correct_count() {\n        let deck = fisher_yates_shuffle(888);\n        let cards = get_cards(deck);\n\n        // Verify we get exactly CARDS_TO_DEAL cards\n        assert(cards.len() == CARDS_TO_DEAL, \"Should return CARDS_TO_DEAL cards\");\n    }\n\n    // -------------------------------------------------------------------------\n    // Integration Tests\n    // -------------------------------------------------------------------------\n\n    #[test]\n    fn test_full_shuffle_and_verify_workflow() {\n        // Simulate the full workflow: shuffle, compute root, extract cards\n        let seed: Field = 0xdeadbeef;\n\n        // Step 1: Shuffle\n        let deck = fisher_yates_shuffle(seed);\n\n        // Step 2: Compute merkle root (for on-chain commitment)\n        let root = merkle_root(deck, seed);\n\n        // Step 3: Extract cards for gameplay\n        let cards = get_cards(deck);\n\n        // Verify: Re-compute and check consistency\n        let deck_verify = fisher_yates_shuffle(seed);\n        let root_verify = merkle_root(deck_verify, seed);\n        let cards_verify = get_cards(deck_verify);\n\n        assert(root == root_verify, \"Root should match on re-computation\");\n        for i in 0..CARDS_TO_DEAL {\n            assert(cards[i] == cards_verify[i], \"Cards should match on re-computation\");\n        }\n    }\n\n    // -------------------------------------------------------------------------\n    // Calculate Commitment Tests\n    // -------------------------------------------------------------------------\n\n    #[test]\n    fn test_calculate_commitment_is_deterministic() {\n        // Same inputs must produce the same commitments\n        let cards: [Field; 10] = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n        let players: [Field; 5] = [100, 200, 300, 400, 500];\n        let player_status: [bool; 5] = [true, true, true, true, true];\n\n        let commitments1 = calculate_commitment(cards, players, player_status);\n        let commitments2 = calculate_commitment(cards, players, player_status);\n\n        for i in 0..10 {\n            assert(commitments1[i] == commitments2[i], \"Commitments must be deterministic\");\n        }\n    }\n\n    #[test]\n    fn test_calculate_commitment_all_players_active() {\n        // When all players are active, all commitments should be non-zero\n        let cards: [Field; 10] = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n        let players: [Field; 5] = [100, 200, 300, 400, 500];\n        let player_status: [bool; 5] = [true, true, true, true, true];\n\n        let commitments = calculate_commitment(cards, players, player_status);\n\n        for i in 0..10 {\n            assert(commitments[i] != 0, \"Active player commitments should be non-zero\");\n        }\n    }\n\n    #[test]\n    fn test_calculate_commitment_all_players_inactive() {\n        // When all players are inactive, all commitments should be zero\n        let cards: [Field; 10] = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n        let players: [Field; 5] = [100, 200, 300, 400, 500];\n        let player_status: [bool; 5] = [false, false, false, false, false];\n\n        let commitments = calculate_commitment(cards, players, player_status);\n\n        for i in 0..10 {\n            assert(commitments[i] == 0, \"Inactive player commitments should be zero\");\n        }\n    }\n\n    #[test]\n    fn test_calculate_commitment_partial_players() {\n        // Mixed active/inactive players\n        let cards: [Field; 10] = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n        let players: [Field; 5] = [100, 200, 300, 400, 500];\n        // Players 0, 2, 4 are active; players 1, 3 are inactive\n        let player_status: [bool; 5] = [true, false, true, false, true];\n\n        let commitments = calculate_commitment(cards, players, player_status);\n\n        // Player 0 (cards 0, 1) - active\n        assert(commitments[0] != 0, \"Player 0 card 0 should have commitment\");\n        assert(commitments[1] != 0, \"Player 0 card 1 should have commitment\");\n\n        // Player 1 (cards 2, 3) - inactive\n        assert(commitments[2] == 0, \"Player 1 card 0 should be zero\");\n        assert(commitments[3] == 0, \"Player 1 card 1 should be zero\");\n\n        // Player 2 (cards 4, 5) - active\n        assert(commitments[4] != 0, \"Player 2 card 0 should have commitment\");\n        assert(commitments[5] != 0, \"Player 2 card 1 should have commitment\");\n\n        // Player 3 (cards 6, 7) - inactive\n        assert(commitments[6] == 0, \"Player 3 card 0 should be zero\");\n        assert(commitments[7] == 0, \"Player 3 card 1 should be zero\");\n\n        // Player 4 (cards 8, 9) - active\n        assert(commitments[8] != 0, \"Player 4 card 0 should have commitment\");\n        assert(commitments[9] != 0, \"Player 4 card 1 should have commitment\");\n    }\n\n    #[test]\n    fn test_calculate_commitment_card_player_mapping() {\n        // Verify that each pair of cards maps to the correct player\n        // Card 0,1 -> Player 0; Card 2,3 -> Player 1; etc.\n        let cards: [Field; 10] = [05, 10, 15, 20, 25, 30, 35, 40, 45, 50];\n        let players: [Field; 5] = [1, 2, 3, 4, 5];\n        let player_status: [bool; 5] = [true, true, true, true, true];\n\n        let commitments = calculate_commitment(cards, players, player_status);\n\n        // Manually verify the expected commitment hashes\n        // commitment[i] = Poseidon2::hash([cards[i], players[i/2]], 2)\n        let expected_0 = Poseidon2::hash([05, 1], 2); // card 0, player 0\n        let expected_1 = Poseidon2::hash([10, 1], 2); // card 1, player 0\n        let expected_2 = Poseidon2::hash([15, 2], 2); // card 2, player 1\n        let expected_3 = Poseidon2::hash([20, 2], 2); // card 3, player 1\n        let expected_4 = Poseidon2::hash([25, 3], 2); // card 4, player 2\n        let expected_5 = Poseidon2::hash([30, 3], 2); // card 5, player 2\n        let expected_6 = Poseidon2::hash([35, 4], 2); // card 6, player 3\n        let expected_7 = Poseidon2::hash([40, 4], 2); // card 7, player 3\n        let expected_8 = Poseidon2::hash([45, 5], 2); // card 8, player 4\n        let expected_9 = Poseidon2::hash([50, 5], 2); // card 9, player 4\n\n        assert(commitments[0] == expected_0, \"Card 0 commitment mismatch\");\n        assert(commitments[1] == expected_1, \"Card 1 commitment mismatch\");\n        assert(commitments[2] == expected_2, \"Card 2 commitment mismatch\");\n        assert(commitments[3] == expected_3, \"Card 3 commitment mismatch\");\n        assert(commitments[4] == expected_4, \"Card 4 commitment mismatch\");\n        assert(commitments[5] == expected_5, \"Card 5 commitment mismatch\");\n        assert(commitments[6] == expected_6, \"Card 6 commitment mismatch\");\n        assert(commitments[7] == expected_7, \"Card 7 commitment mismatch\");\n        assert(commitments[8] == expected_8, \"Card 8 commitment mismatch\");\n        assert(commitments[9] == expected_9, \"Card 9 commitment mismatch\");\n    }\n\n    #[test]\n    fn test_calculate_commitment_different_players_different_commitments() {\n        // Same card with different players should produce different commitments\n        let cards: [Field; 10] = [42, 42, 42, 42, 42, 42, 42, 42, 42, 42]; // all same card\n        let players: [Field; 5] = [1, 2, 3, 4, 5]; // different players\n        let player_status: [bool; 5] = [true, true, true, true, true];\n\n        let commitments = calculate_commitment(cards, players, player_status);\n\n        // Commitments for the same card but different players should differ\n        // Group by player: (0,1), (2,3), (4,5), (6,7), (8,9)\n        // Compare commitments across different player groups\n        assert(\n            commitments[0] != commitments[2],\n            \"Different players should have different commitments\",\n        );\n        assert(\n            commitments[2] != commitments[4],\n            \"Different players should have different commitments\",\n        );\n        assert(\n            commitments[4] != commitments[6],\n            \"Different players should have different commitments\",\n        );\n        assert(\n            commitments[6] != commitments[8],\n            \"Different players should have different commitments\",\n        );\n    }\n\n    #[test]\n    fn test_calculate_commitment_different_cards_same_player() {\n        // Different cards for the same player should produce different commitments\n        let cards: [Field; 10] = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]; // different cards\n        let players: [Field; 5] = [100, 100, 100, 100, 100]; // all same player\n        let player_status: [bool; 5] = [true, true, true, true, true];\n\n        let commitments = calculate_commitment(cards, players, player_status);\n\n        // Each card should produce a unique commitment\n        for i in 0..10 {\n            for j in (i + 1)..10 {\n                assert(\n                    commitments[i] != commitments[j],\n                    \"Different cards should have different commitments\",\n                );\n            }\n        }\n    }\n\n    #[test]\n    fn test_calculate_commitment_with_zero_values() {\n        // Edge case: zero-valued cards and players\n        let cards: [Field; 10] = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\n        let players: [Field; 5] = [0, 0, 0, 0, 0];\n        let player_status: [bool; 5] = [true, true, true, true, true];\n\n        let commitments = calculate_commitment(cards, players, player_status);\n\n        // All commitments should be the same since all inputs are identical\n        let expected = Poseidon2::hash([0, 0], 2);\n        for i in 0..10 {\n            assert(commitments[i] == expected, \"Zero values should still produce valid hash\");\n        }\n    }\n\n    #[test]\n    fn test_calculate_commitment_single_player_active() {\n        // Only one player is active\n        let cards: [Field; 10] = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n        let players: [Field; 5] = [100, 200, 300, 400, 500];\n        let player_status: [bool; 5] = [false, false, true, false, false]; // only player 2 active\n\n        let commitments = calculate_commitment(cards, players, player_status);\n\n        // Only cards 4 and 5 (belonging to player 2) should have commitments\n        assert(commitments[0] == 0, \"Player 0 should be inactive\");\n        assert(commitments[1] == 0, \"Player 0 should be inactive\");\n        assert(commitments[2] == 0, \"Player 1 should be inactive\");\n        assert(commitments[3] == 0, \"Player 1 should be inactive\");\n        assert(commitments[4] != 0, \"Player 2 card 0 should have commitment\");\n        assert(commitments[5] != 0, \"Player 2 card 1 should have commitment\");\n        assert(commitments[6] == 0, \"Player 3 should be inactive\");\n        assert(commitments[7] == 0, \"Player 3 should be inactive\");\n        assert(commitments[8] == 0, \"Player 4 should be inactive\");\n        assert(commitments[9] == 0, \"Player 4 should be inactive\");\n    }\n\n    // -------------------------------------------------------------------------\n    // Reveal Circuit Integration Test\n    // -------------------------------------------------------------------------\n\n    #[test]\n    fn test_commitment_verification_workflow() {\n        // Simulates the reveal circuit verification workflow\n        let cards: [Field; 10] = [5, 15, 25, 35, 45, 10, 20, 30, 40, 50];\n        let players: [Field; 5] = [0xAAA, 0xBBB, 0xCCC, 0xDDD, 0xEEE];\n        let player_status: [bool; 5] = [true, true, true, true, true];\n\n        // Step 1: Calculate commitments (done during deal phase)\n        let onchain_commitments = calculate_commitment(cards, players, player_status);\n\n        // Step 2: Later, recalculate commitments (done during reveal phase)\n        let reveal_commitments = calculate_commitment(cards, players, player_status);\n\n        // Step 3: Verify they match (as the reveal circuit would do)\n        for i in 0..player_status.len() {\n            if player_status[i] {\n                assert(\n                    reveal_commitments[2 * i] == onchain_commitments[2 * i],\n                    \"Card commitment mismatch at showdown\",\n                );\n                assert(\n                    reveal_commitments[2 * i + 1] == onchain_commitments[2 * i + 1],\n                    \"Card commitment mismatch at showdown for player\",\n                );\n            }\n        }\n    }\n\n    // -------------------------------------------------------------------------\n    // Calculate Community Commitment Tests\n    // -------------------------------------------------------------------------\n\n    #[test]\n    fn test_calculate_community_commitment_is_deterministic() {\n        // Same inputs must produce the same commitment\n        let cards: [Field; 5] = [10, 20, 30, 40, 50];\n\n        let commitment1 = calculate_community_commitment(cards);\n        let commitment2 = calculate_community_commitment(cards);\n\n        assert(commitment1 == commitment2, \"Community commitment must be deterministic\");\n    }\n\n    #[test]\n    fn test_calculate_community_commitment_different_cards() {\n        // Different community cards should produce different commitments\n        let cards1: [Field; 5] = [1, 2, 3, 4, 5];\n        let cards2: [Field; 5] = [6, 7, 8, 9, 10];\n\n        let commitment1 = calculate_community_commitment(cards1);\n        let commitment2 = calculate_community_commitment(cards2);\n\n        assert(commitment1 != commitment2, \"Different cards should produce different commitments\");\n    }\n\n    #[test]\n    fn test_calculate_community_commitment_order_matters() {\n        // The order of cards affects the commitment (important for flop, turn, river)\n        let cards1: [Field; 5] = [1, 2, 3, 4, 5];\n        let cards2: [Field; 5] = [5, 4, 3, 2, 1]; // reversed order\n\n        let commitment1 = calculate_community_commitment(cards1);\n        let commitment2 = calculate_community_commitment(cards2);\n\n        assert(commitment1 != commitment2, \"Card order should affect commitment\");\n    }\n\n    #[test]\n    fn test_calculate_community_commitment_integration_with_dealing() {\n        // Full workflow: shuffle -> get cards -> extract community cards -> commit\n        let seed: Field = 0xc0ffee;\n        let deck = fisher_yates_shuffle(seed);\n        let dealt_cards = get_cards(deck);\n\n        // Community cards are the last 5 of the 15 dealt cards (indices 10-14)\n        let community_cards: [Field; 5] =\n            [dealt_cards[10], dealt_cards[11], dealt_cards[12], dealt_cards[13], dealt_cards[14]];\n\n        // Calculate commitment\n        let commitment1 = calculate_community_commitment(community_cards);\n\n        // Re-run the entire workflow for verification\n        let deck_verify = fisher_yates_shuffle(seed);\n        let dealt_verify = get_cards(deck_verify);\n        let community_verify: [Field; 5] = [\n            dealt_verify[10],\n            dealt_verify[11],\n            dealt_verify[12],\n            dealt_verify[13],\n            dealt_verify[14],\n        ];\n        let commitment2 = calculate_community_commitment(community_verify);\n\n        assert(commitment1 == commitment2, \"Community commitment should be reproducible from seed\");\n    }\n\n    #[test]\n    fn test_calculate_community_commitment_unique_for_different_deals() {\n        // Different shuffles should produce different community commitments\n        let deck1 = fisher_yates_shuffle(111);\n        let deck2 = fisher_yates_shuffle(222);\n\n        let cards1 = get_cards(deck1);\n        let cards2 = get_cards(deck2);\n\n        let community1: [Field; 5] = [cards1[10], cards1[11], cards1[12], cards1[13], cards1[14]];\n        let community2: [Field; 5] = [cards2[10], cards2[11], cards2[12], cards2[13], cards2[14]];\n\n        let commitment1 = calculate_community_commitment(community1);\n        let commitment2 = calculate_community_commitment(community2);\n\n        assert(\n            commitment1 != commitment2,\n            \"Different shuffles should produce different community commitments\",\n        );\n    }\n}\n","path":"/home/ally/DevEnv/pvtDock/KH/poker-solana/backend/src/services/circuitry/assist/src/lib.nr"},"60":{"source":"use std::default::Default;\nuse std::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        self.state[0] += self.cache[0];\n        self.state[1] += self.cache[1];\n        self.state[2] += self.cache[2];\n        self.state = crate::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut state = [0; 4];\n        state[RATE] = iv;\n\n        if std::runtime::is_unconstrained() {\n            for i in 0..(in_len / RATE) {\n                state[0] += input[i * RATE];\n                state[1] += input[i * RATE + 1];\n                state[2] += input[i * RATE + 2];\n                state = crate::poseidon2_permutation(state, 4);\n            }\n\n            // handle remaining elements after last full RATE-sized chunk\n            let remainder_start = (in_len / RATE) * RATE;\n            for j in remainder_start..in_len {\n                state[j - remainder_start] += input[j];\n            }\n        } else {\n            let mut states: [[Field; 4]; N / RATE + 1] = [[0; 4]; N / RATE + 1];\n            states[0] = state;\n\n            // process all full RATE-sized chunks, storing state after each permutation\n            for chunk_idx in 0..(N / RATE) {\n                for i in 0..RATE {\n                    state[i] += input[chunk_idx * RATE + i];\n                }\n                state = crate::poseidon2_permutation(state, 4);\n                states[chunk_idx + 1] = state;\n            }\n\n            // get state at the last full block before in_len\n            let first_partially_filled_chunk = in_len / RATE;\n            state = states[first_partially_filled_chunk];\n\n            // handle remaining elements after last full RATE-sized chunk\n            let remainder_start = (in_len / RATE) * RATE;\n            for j in 0..RATE {\n                let idx = remainder_start + j;\n                if idx < in_len {\n                    state[j] += input[idx];\n                }\n            }\n        }\n\n        // always run final permutation unless we just completed a full chunk\n        // still need to permute once if in_len is 0\n        if (in_len == 0) | (in_len % RATE != 0) {\n            state = crate::poseidon2_permutation(state, 4)\n        };\n\n        state[0]\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n","path":"/home/ally/nargo/github.com/noir-lang/poseidon/v0.2.2/src/poseidon2.nr"}},"expression_width":{"Bounded":{"width":4}}}